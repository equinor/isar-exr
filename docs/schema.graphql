# Represents different classes of objects on the site that are no inspection targets but has robot interaction.
interface AbstractSiteObjectType {
  # The unique identifier of the site object.
  id: ID!

  # The unique identifier of the site object.
  key: String!

  # A human readable name of the site object.
  name: String!

  # The site this site object  is located on.
  site: SiteType!

  # The type of the site object.
  type: SiteObjectTypeEnum!

  # The pose of the site object.
  pose: Pose3DStampedType!
}

# The different site object types.
enum SiteObjectTypeEnum {
  # Site object represents a docking station.
  DOCKING_STATION
}

# This type represents the structure of a mission task definitions. This is a template for specific mission task definition.
interface AbstractMissionTaskDefinitionType {
  # The unique identifier of this task definition.
  id: ID!

  # Whether or not this mission task definition is used in a dynamic mission. Dynamic missions are generated to execute a single task on depend.
  isDynamicMission: Boolean!

  # A human readable name of the task.
  name: String!

  # The type of this task.
  type: MissionTaskDefinitionTypeEnum!

  # The waypoint of this task.
  waypoint: WaypointType
}

# Represents the type of a mission task definition.
enum MissionTaskDefinitionTypeEnum {
  # The start action of each mission. It is used to initialize the robot for the mission. Depending on the docking state, it will undock the robot.
  START_MISSION

  # Drive the robot back to the desired docking station and perform docking.
  DOCK_ROBOT

  # The task consists of the inspection of a provided point of interest
  POI_INSPECTION

  # The task consists of a waypoint
  WAYPOINT
}

# The common properties of a data payload. The details are provided in specific type implementations.
interface AbstractDataPayloadType {
  # The unique identifier of this payload.
  id: ID!

  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The type of this payload.
  dataType: DataPayloadTypeEnum!

  # The producer of this payload. Can be null for Energy Robotics.
  producer: DataPayloadProducerType

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # (For future use, currently always null) The region of interest on the site were the data has been recorded. It has been either a point of interest or an area of interest.
  regionOfInterest: RegionOfInterestUnion

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean!
}

# Represents the type of an payload recorded by a robot.
enum DataPayloadTypeEnum {
  # The recorded data is an image. Typically it is stored as a PNG.
  PHOTO

  # The recorded payload is an video file. Typically it is stored in the MP4 format using H.264 encoding.
  VIDEO

  # The recorded payload is an audio file. Typically it is stored in the WEBM format.
  AUDIO

  # The recorded payload has the form of a 1D time series. This means we have have a discrete series of timestamps. For every timestamp we have a corresponding scalar value (e.g. temperature measurements).
  TIME_SERIES_1D

  # A superset of the PHOTO type but with the option to render (multiple) svg based overlays on top of it.
  PHOTO_OVERLAY

  # The recorded data is provided as JSON. The schema is defined by the data producer. Typically the producer is a skill.
  JSON_DATA

  # Represents a composite type to group multiple payloads together.
  GROUP
}

union RegionOfInterestUnion = AreaOfInterestType | PointOfInterestType

# Represents an area of interest that is or was located on a customer site. It is currently considered for undirected, omni-directional measurements only.
type AreaOfInterestType {
  # The unique identifier of the area of interest.
  id: ID!

  # The human-readable name of the area of interest.
  name: String!

  # The site this area of interest is located on
  site: SiteType!
}

# Represents the position of a point in the free 3D space.
type Point3DType {
  x: Float!
  y: Float!
  z: Float!
}

# Represents an orientation in the free 3D space in quaternion form.
type QuaternionType {
  w: Float!
  x: Float!
  y: Float!
  z: Float!
}

# Represents a 3D pose in the free 3D space at a given time. Optional a coordinate frame is provided.
type Pose3DStampedType {
  # The timestamp the data is generated.
  timestamp: Timestamp!

  # The reference coordinate frame, the data is associated with
  frameID: String

  # Represents the position of the pose.
  position: Point3DType!

  # Represents the orientation of the pose.
  orientation: QuaternionType!
}

# The `Timestamp` type as integer. Type represents date and time as number of milliseconds from start of UNIX epoch (midnight on January 1, 1970, UTC). This is not the same as the UNIX time (the number of seconds that have elapsed since midnight on January 1, 1970, UTC)!
scalar Timestamp

# Represents a point of interest that is or was located on a customer site.
type PointOfInterestType {
  # The unique identifier of the point of interest.
  id: ID!

  # The external generated unique key of the poi.
  key: String!

  # The human-readable name of the point of interest
  name: String!

  # The type of this point of interest.
  type: PointOfInterestTypeEnum!

  # The site this point of interest is located on
  site: SiteType!

  # The pose of the point of interest
  pose: Pose3DStampedType!

  # The actions of the poi
  actions: [PointOfInterestsActionsType!]!

  # The generated inspection parameters
  inspectionParameters: Json!
}

# Represents the type of an point of interest. This list will be extended in the future.
enum PointOfInterestTypeEnum {
  # The poi is a manometer.
  MANOMETER

  # The poi is a fire extinguisher.
  FIRE_EXTINGUISHER

  # The fallback type. Non of the previous types fits the poi.
  GENERIC
}

union PointOfInterestsActionsType =
    PointOfInterestsActionsPhotoType
  | PointOfInterestsActionsVideoType

# Represents a photo action of the POI.
type PointOfInterestsActionsPhotoType {
  robotPose: Pose3DStampedType!
}

# Represents a video action of the POI.
type PointOfInterestsActionsVideoType {
  robotPose: Pose3DStampedType!
  duration: Float!
}

# The `Json` type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). The type is encoded as a `JSON string`. You have to parse it e.g. by `JSON.parse(value)` to receive the JSON object.
scalar Json

# Represents a 3D pose in the free 3D space.
type Pose3DType {
  # Represents the position of the pose.
  position: Point3DType!

  # Represents the orientation of the pose.
  orientation: QuaternionType!
}

# Represents limits for a region of interest selection.
type RegionOfInterestLimitType {
  width: Float!
  height: Float!
}

# Describes the properties of a single camera.
type CameraDescriptionType {
  # The unique identifier of the camera.
  id: ID!

  # The human-readable name of the camera.
  name: String!

  # The topic name of the WebRTC resource. It should be used to offer a peer for a this camera specific camera.
  webRtcTopic: String!

  # The topic name of the WebRTC resource. It should be used to offer a peer for a this camera specific camera.
  webRTCTopic: String!
    @deprecated(
      reason: "[10.11.2022] renamed for consistency reasons. Use 'webRtcTopic' instead"
    )

  # Whether or not the camera supports region of interest selection.
  regionOfInterestSupported: String!

  # The limits of the region of interest selection.
  maximumRegionOfInterest: RegionOfInterestLimitType
}

# Represents the camera configuration of a robot.
type CameraConfigType {
  # The websocket endpoint to access the WebRTC-based camera streams.
  webRtcWebsocketUri: Uri!

  # The websocket endpoint to access the WebRTC-based camera streams.
  webRTCWebsocketURI: Uri!
    @deprecated(
      reason: "[10.11.2022] renamed for consistency reasons. Use 'webRTCWebsocketUri' instead"
    )

  # Contains the URIs of the available WebRTC turn servers
  webRtcTurnServerUris: [Uri!]!

  # Contains the URIs of the available WebRTC turn servers
  webRTCTurnServerURIs: [Uri!]!
    @deprecated(
      reason: "[10.11.2022] renamed for consistency reasons. Use 'webRtcTurnServerUris' instead"
    )

  # The primary camera used for inspection.
  inspectionCamera: CameraDescriptionType

  # The primary camera used for teleoperated driving.
  drivingCamera: CameraDescriptionType

  # Number of cameras available.
  count: Int!

  # The list of available cameras.
  cameras: [CameraDescriptionType!]!
}

# The `Uri` type as string encoded as specified in [RFC 3986 on URI](https://datatracker.ietf.org/doc/html/rfc3986). Note that the strings are not considered as percent-encoded. You need to encode them after receiving by e.g. `encodeURI()` and decode them before sending by e.g. `decodeURI()`
scalar Uri

# Represents a bin for a sensor data discretization
type SensorDataDiscretizationType {
  # The name of the bin
  name: String!

  # The min value of the bin
  minValue: Float!

  # The may value of the bin
  maxValue: Float!
}

# Represents the data description of one dimensional sensor data
type SensorDataDescriptionType {
  # The human readable name of the data measured by the sensor.
  name: String!

  # An abbreviation of the name
  abbreviation: String!

  # The physical unit of the measurements
  unit: String!

  # The default unit range
  unitRange: Float!

  # An optional discretization of the sensor data
  discretization: [SensorDataDiscretizationType!]
}

# Represents a single sensor on a robot
type SensorDescriptionType {
  # The unique id of the sensor
  id: ID!

  # The data port of the sensor
  dataPort: Int!

  # The power port of the sensor
  powerPort: Int!

  # An offset of the analog signal. It is assumed to be zero if not set.
  analogInZeroOffset: Float

  # The description of the sensor data
  dataDescription: SensorDataDescriptionType!
}

# Represents the full sensor configuration of a robot
type SensorConfigType {
  # The list of available sensors
  sensors: [SensorDescriptionType!]!
}

# Represents the configuration and capabilities of a robot. An important use case for this information is to check whether or not a robot is capable of executing a mission.
type RobotConfigType {
  # The type of the robot.
  type: RobotTypeEnum!
    @deprecated(
      reason: "[10.11.2022] The field has been moved to the robot type"
    )

  # The region of the robot, eg. "eu".
  region: String!

  # The local pose of the robots' map coordinate system inside the site coordinate system.
  originPose: Pose3DType!
    @deprecated(
      reason: "[10.11.2022] Conceptual changes make this property useless. It will always return the origin"
    )

  # The type of locomotion.
  locomotionType: LocomotionTypeEnum!
    @deprecated(
      reason: "[10.11.2022] The field has been moved to the robot type"
    )

  # Weather or not the robot has moving joints.
  hasMovingJoints: Boolean!

  # The URDF of the robot.
  urdf: Urdf

  # The accent color for this robot in the user interface.
  color: Color!

  # All camera related configurations of this robot.
  cameraConfig: CameraConfigType!

  # All camera related configurations of this robot.
  sensorConfig: SensorConfigType!
}

# Represents the type of robot.
enum RobotTypeEnum {
  # The legged Boston Dynamics Spot robot. This robot is capable of full autonomy.
  SPOT

  # The IECEX and ATEX certified ExR-1 robot by Ex Robotics. This robot is restricted to line-following autonomy.
  EXR1
    @deprecated(
      reason: "[10.11.2022] This robot type will not be supported in the future."
    )

  # The IECEX and ATEX certified ExR-2 robot by Ex Robotics. This robot is capable of full autonomy.
  EXR2

  # The Rover robot by Rover Robotics equipped with a custom payload. This robot is capable of full autonomy.
  ROVER

  # A flying robot (drone) by DJI. This robot is capable of full autonomy.
  DJI_DRONE
}

# Represents the methods that the robot uses to transport itself from place to place.
enum LocomotionTypeEnum {
  # The robot is equipped with two continuous tracks.
  TRACKED

  # The robot is equipped with two four legs.
  FOUR_LEGGED

  # The robot flies.
  FLYING
}

# The robot description provided in the URDF format.
scalar Urdf

# Represents a color according to a css color
scalar Color

# Represents the basic information of a robot.
type RobotType {
  # The unique identifier of the robot.
  id: ID!

  # The robot number is unique number for each robot.
  number: Int!

  # The type of the robot.
  type: RobotTypeEnum!

  # The type of locomotion of the robot.
  locomotionType: LocomotionTypeEnum!

  # The human-readable name of the robot.
  name: String!

  # The specific configuration of this robot. It consists of the specific capabilities and sensors available on the robot.
  config: RobotConfigType!

  # The deployment site of this robot.
  site: SiteType
}

# Represents the color configuration of a point cloud.
type PointCloudColorConfigType {
  # The type of the point cloud.
  type: PointCloudShadingTypeEnum!

  # The color of the point cloud.
  value: Color

  # The opacity of the color.
  opacity: Float!
}

# Represents the shading of a point cloud.
enum PointCloudShadingTypeEnum {
  # Every point has the same color.
  UNIFORM

  # Each individual point contains rgb color information.
  MULTI_COLOR

  # Each individual point contains an intensity vaule.
  INTENSITY
}

# Represents the configuration of the sites' point cloud.
type PointCloudConfigType {
  # An uri to the point cloud resource (either the file or the data stream).
  uri: Uri!

  # The type of the point cloud.
  type: PointCloudTypeEnum!

  # The color of the point cloud.
  color: PointCloudColorConfigType!

  # The size of the points.
  size: Float!
}

# Represents the format or type of point cloud.
enum PointCloudTypeEnum {
  # The PLY file format.
  PLY

  # The PCD file format.
  PCD
}

# Represents the configuration of the sensors of a particular site.
type SiteSensorConfigLimitType {
  # The lower limit of the sensor.
  lower: Float

  # The upper limit of the sensor.
  upper: Float

  # The tag associated with these limits.
  tag: String!
}

# Represents the configuration of the sensors of a particular site.
type SiteSensorConfigType {
  # The abbreviation of the measured physical phenomenon.
  abbreviation: String!

  # The sensor limit thresholds.
  limits: [SiteSensorConfigLimitType!]!
}

# Represents the configuration of the site.
type SiteConfigType {
  # The region of the site, eg. "eu".
  region: String!

  # All point cloud related configurations of this site
  pointCloudConfig: PointCloudConfigType

  # All sensor related configurations of this site
  sensorConfig: [SiteSensorConfigType!]!
}

# Represents a robot docking station placed on the site.
type DockingStationSiteObjectType implements AbstractSiteObjectType {
  # The unique identifier of the site object.
  id: ID!

  # The unique identifier of the site object.
  key: String!

  # A human readable name of the site object.
  name: String!

  # The site this site object  is located on.
  site: SiteType!

  # The type of the site object.
  type: SiteObjectTypeEnum!

  # The pose of the site object.
  pose: Pose3DStampedType!

  # The waypoint in front of the docking station that allows it to perform the docking behavior.
  waypoint: Pose3DStampedType!

  # The robot type that is compatible with this docking station
  compatibleRobotType: RobotTypeEnum!
}

# Represents a customer site on which one or more robots operates on.
type SiteType {
  # The unique identifier of the site.
  id: ID!

  # A unique number of the site.
  number: Int!

  # The human-readable name of the site.
  name: String!

  # Optional, a location description of the site.
  location: String

  # The robots operating on this site.
  robots: [RobotType!]!

  # The current map key used for navigation and visualization
  mapKey: String!

  # The points of interest (POIs) available on this site.
  pointsOfInterest: [PointOfInterestType!]!

  # The areas of interest (AOIs) available on this site.
  areasOfInterest: [AreaOfInterestType!]!

  # A list of non-injectable objects of this site.
  siteObjects: [AbstractSiteObjectType!]!

  # The configuration of this site.
  config: SiteConfigType!
}

# Represents the subscription type for a sites.
type SiteSubscriptionType {
  # The timestamp of this subscription message.
  timestamp: Timestamp!

  # The operation which has been applied to the site.
  operation: DataOperationTypeEnum!

  # The site if only one is affected.
  site: SiteType
}

# Represents a operation which has been applied to some data.
enum DataOperationTypeEnum {
  # The data has been created.
  CREATE

  # The data has been updated.
  UPDATE

  # The data has been deleted.
  DELETE

  # Multiple entities of the data type have been deleted.
  DELETE_MANY
}

# Represents the subscription type of a robot
type RobotSubscriptionType {
  # The timestamp of the message
  timestamp: Timestamp!

  # The robot
  robot: RobotType!
}

# Represents the subscription type for a point of interest.
type PointOfInterestSubscriptionType {
  # The timestamp of this subscription message.
  timestamp: Timestamp!

  # The operation which has been applied to the point of interest.
  operation: DataOperationTypeEnum!

  # The point of interest if only one is affected.
  pointOfInterest: PointOfInterestType
}

type PageDataType {
  count: Float!
  limit: Float!
  offset: Float!
}

# A SiteSnapshot represents a specific site configuration at a certain timestamp. This includes points of interests, site objects, maps and more.
type SiteSnapshotType {
  # The unique identifier of the site snapshot.
  id: ID!

  # The timestamp this snapshot has been created.
  timestamp: Timestamp!

  # Whether or not this snapshot is the current head.
  isCurrentHead: Boolean!

  # The human-readable name of the site.
  name: String!

  # The site number is unique number for each site.
  number: Int!

  # The key of the map of this snapshot
  mapKey: String!

  # The points of interest (POIs) available on this site at the time of the snapshot
  pointsOfInterest: [PointOfInterestType!]!

  # A list of non-injectable objects of this site at the time of the snapshot
  siteObjects: [AbstractSiteObjectType!]!
}

type SiteSnapshotsType {
  page: SiteSnapshotTypeConnection!
  pageData: PageDataType
}

type SiteSnapshotTypeConnection {
  edges: [SiteSnapshotTypeEdge!]
  pageInfo: SiteSnapshotTypePageInfo
}

type SiteSnapshotTypeEdge {
  cursor: String
  node: SiteSnapshotType
}

type SiteSnapshotTypePageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

# Represents the current changes to a site that have not been committed yet
type SiteStageType {
  # The id of the site stage
  id: ID!

  # The state of the stage
  state: SiteStageStateEnum!

  # The snapshot this stage is based on
  siteSnapshotHead: SiteSnapshotType!

  # The new map key
  mapKey: String!

  # The list of points of interest that will be added with this stage
  poiAddList: [PointOfInterestType!]!

  # The list of site objects that will be added with this stage
  siteObjectAddList: [AbstractSiteObjectType!]!
}

# Represents the state of a site stage.
enum SiteStageStateEnum {
  # The stage is open and has not been committed yet.
  OPEN

  # The stage has been discarded without being committed.
  DISCARDED

  # The stage has been committed.
  COMMITTED
}

# Represents the subscription type of a site stage
type SiteStageStatusType {
  # The timestamp of the status
  timestamp: Timestamp!

  # The stage
  stage: SiteStageType!
}

# Represents a user of the ER system
type UserType {
  userId: Int!
  name: String!
  email: String!
  isEngineer: Boolean!
}

# A RobotSnapshot represents a specific robot configuration at a certain timestamp. A snapshot is owned by the site the robot was operating on. This has the effect of a new snapshot if the robot is moved to a new site or the configuration has changed.
type RobotSnapshotType {
  # The timestamp this snapshot has been created.
  timestamp: Timestamp!

  # The robot number of the robot.
  number: Int!

  # The type of the robot.
  type: RobotTypeEnum!

  # The human readable name of the robot.
  name: String!

  # The robot config of the robot during this snapshot.
  config: RobotConfigType!
}

# Represents a site recording performed by a robot
type SiteRecordingType {
  # The id of the recording
  id: ID!

  # The timestamp the recording has been started
  timestamp: Timestamp!

  # The state of the recording
  state: SiteRecordingStateEnum!

  # Doing a running recording the robot that performs the recording. For all completed recordings the snap shot of the robot doing the recording.
  robot: RobotUnion!

  # The stage associated with the recording
  siteStage: SiteStageType!
}

# Represents the site recording state
enum SiteRecordingStateEnum {
  # A request to start a site recording has been sent to the robot
  START_REQUESTED

  # The robot received the start recording request and has accepted it
  START_ACCEPTED

  # The recording has been started by the robot
  STARTED

  # A request to stop a site recording has been sent to the robot
  STOP_REQUESTED

  # The robot received the stop recording request and has accepted it
  STOP_ACCEPTED

  # The recording has been stopped
  STOPPED

  # A request to decline a site recording has been sent to the robot
  DECLINE_REQUESTED

  # The robot received the decline recording request and has accepted it
  DECLINE_ACCEPTED

  # The recording has been declined
  DECLINED

  # The recording has failed and was rejected by the robot
  REJECTED

  # The previous issued command has failed
  COMMAND_FAILED
}

union RobotUnion = RobotType | RobotSnapshotType

# Represents the subscription type of a site recording
type SiteRecordingStatusType {
  # The timestamp of the status
  timestamp: Timestamp!

  # The recording
  recording: SiteRecordingType
}

# Represents an internal site recording action request to the robot
type SiteRecordingControlRequestType {
  # The timestamp of the request
  timestamp: Timestamp!

  # The requested action
  action: SiteRecordingControlActionEnum!

  # The current recording
  recording: SiteRecordingType!
}

# Represents the control actions for the site recording
enum SiteRecordingControlActionEnum {
  # A request to start a recording
  START

  # A request to stop a recording
  STOP

  # A request to decline a recording
  DECLINE
}

# Represents a grid map of singed 8 bit integer values.
type GridMapType {
  # The map resolution [m/cell]
  resolution: Float!

  # Map width [cells]
  width: Float!

  # Map height [cells]
  height: Float!

  # The origin of the map [m, m].  This is the real-world pose of the cell (0,0) in the map.
  origin: Point3DType!

  # The tiles of the grid map. This enables to load large grid maps in batches.
  tiles: [GridMapTileType!]!
}

# Represents a single tile of a grid map. A tile is represented as a png.
type GridMapTileType {
  # The uri of the grid map tile.
  uri: Uri!
}

# This task performs the initialization of the robot, as well as the undocking if necessary.
type StartMissionTaskDefinitionType implements AbstractMissionTaskDefinitionType {
  # The unique identifier of this task definition.
  id: ID!

  # Whether or not this mission task definition is used in a dynamic mission. Dynamic missions are generated to execute a single task on depend.
  isDynamicMission: Boolean!

  # A human readable name of the task.
  name: String!

  # The type of this task.
  type: MissionTaskDefinitionTypeEnum!

  # The waypoint of this task.
  waypoint: WaypointType
}

# Represents a waypoint.
type WaypointType {
  # The id of the waypoint
  waypointId: String!

  # The pose of the waypoint
  pose: Pose3DStampedType!
}

# This task performs the docking of the robot.
type DockRobotTaskDefinitionType implements AbstractMissionTaskDefinitionType {
  # The unique identifier of this task definition.
  id: ID!

  # Whether or not this mission task definition is used in a dynamic mission. Dynamic missions are generated to execute a single task on depend.
  isDynamicMission: Boolean!

  # A human readable name of the task.
  name: String!

  # The type of this task.
  type: MissionTaskDefinitionTypeEnum!

  # The waypoint of this task.
  waypoint: WaypointType

  # The docking station the robot is supposed to use.
  dockingStation: DockingStationSiteObjectType!
}

# This task performs an inspection action at the provided poi.
type PoiInspectionTaskDefinitionType implements AbstractMissionTaskDefinitionType {
  # The unique identifier of this task definition.
  id: ID!

  # Whether or not this mission task definition is used in a dynamic mission. Dynamic missions are generated to execute a single task on depend.
  isDynamicMission: Boolean!

  # A human readable name of the task.
  name: String!

  # The type of this task.
  type: MissionTaskDefinitionTypeEnum!

  # The waypoint of this task.
  waypoint: WaypointType

  # The point of interest which should be inspected.
  pointOfInterest: PointOfInterestType!
}

# This task represents a waypoint which should be reached by the robot.
type WaypointTaskDefinitionType implements AbstractMissionTaskDefinitionType {
  # The unique identifier of this task definition.
  id: ID!

  # Whether or not this mission task definition is used in a dynamic mission. Dynamic missions are generated to execute a single task on depend.
  isDynamicMission: Boolean!

  # A human readable name of the task.
  name: String!

  # The type of this task.
  type: MissionTaskDefinitionTypeEnum!

  # The waypoint of this task.
  waypoint: WaypointType
}

type RosStampType {
  secs: Float!
  nsecs: Float!
}

type RosHeaderType {
  seq: Int!
  stamp: RosStampType!
  frame_id: String!
}

type RosPoseStampedType {
  header: RosHeaderType!
  pose: Pose3DType!
}

type RosPathType {
  header: RosHeaderType!
  poses: [RosPoseStampedType!]!
}

# Represents an edge between two waypoints.
type MissionRoadmapEdgeType {
  # The id of the source waypoint
  source_waypoint_id: String!

  # The id of the target waypoint
  target_waypoint_id: String!

  # The path between the two waypoints
  path: RosPathType!

  # Optional a cost which is later used by the Dijkstra algorithm. By default the length of the path is used.
  cost: Float
}

# Represents a roadmap used by a robot to navigate within a mission
type MissionRoadmapType {
  # The id of the roadmap, typically this id corresponds with the mission id it belongs to
  roadmap_id: String!

  # The list of edges in this roadmap
  roadmap_edges: [MissionRoadmapEdgeType!]!
}

# Represents the required configuration of a robot to execute a specific mission.
type RequiredRobotConfigType {
  # Force this mission to be only available for a specific robot.
  robotId: String
}

# Contains the path relevant properties of a mission definition.
type MissionDefinitionPathDataType {
  # The full planned path of this mission.
  fullPath: [Pose3DStampedType!]!

  # Whether or not the mission is still processed. Use subscription to be notified about changes or query the mission later again.
  isProcessing: Boolean!

  # The id of the tasks which are still processing.
  tasksInProgress: [String!]!
}

# Represents the definition of a mission as a result of the mission planning. (Not to be confused with the MissionExecution which represents a specific execution of a MissionDefinition by a specific robot)
type MissionDefinitionType {
  # The unique identifier of the mission definition.
  id: ID!

  # Whether or not this mission is a dynamic mission. Dynamic missions are generated to execute a single task on depend.
  isDynamicMission: Boolean!

  # The legacy mission definition id. Don't use it for mission execution requests!. Use "id" field instead.
  legacyMissionDefinitionId: String
    @deprecated(
      reason: "This field is only available to keep compatibility with a legacy system. It will be removed in the future."
    )

  # A human-readable name of the mission task.
  name: String!

  # The list of mission tasks. If 'legacyMissionDefinitionId' is set, this list will be empty.
  tasks: [AbstractMissionTaskDefinitionType!]!

  # The path details of the mission.
  path: MissionDefinitionPathDataType

  # Defines the required robot configuration to execute this mission definition.
  requiredRobotConfig: RequiredRobotConfigType
}

# Subset of the mission definition type. It does not include large/computational expensive properties like 'tasks' and 'fullPath'. In order to retrieve this data query the specific mission definition explicitly.
type MissionDefinitionsType {
  # The unique identifier of the mission definition.
  id: ID!

  # Whether or not this mission is a dynamic mission. Dynamic missions are generated to execute a single task on depend.
  isDynamicMission: Boolean!

  # The legacy mission definition id. Don't use it for mission execution requests!. Use "id" field instead.
  legacyMissionDefinitionId: String
    @deprecated(
      reason: "This field is only available to keep compatibility with a legacy system. It will be removed in the future."
    )

  # A human-readable name of the mission task.
  name: String!

  # Defines the required robot configuration to execute this mission definition.
  requiredRobotConfig: RequiredRobotConfigType
}

# Represents the subscription type for a mission definition.
type MissionDefinitionSubscriptionType {
  # The timestamp of this subscription message.
  timestamp: Timestamp!

  # The operation which has been applied to the mission definition.
  operation: DataOperationTypeEnum!

  # The mission definition if only one is affected.
  missionDefinition: MissionDefinitionType
}

# Represents the sender of a chat message
type ChatUserType {
  # The id of the user
  userId: String!

  # The name of the user
  name: String!

  # Whether or not the user is an energy robotics user
  isERUser: Boolean!

  # Whether or not the message is from the current user
  isCurrentUser: Boolean!
}

# Represents a single message in the chat system
type ChatMessageType {
  # The unique id of the message
  id: String!

  # The timestamp of the message
  timestamp: Timestamp!

  # The text message
  message: String!

  # The sender of the message
  user: ChatUserType!
}

# Represents a paginated batch of chat messages
type ChatMessagesType {
  page: ChatMessageTypeConnection!
  pageData: PageDataType
}

type ChatMessageTypeConnection {
  edges: [ChatMessageTypeEdge!]
  pageInfo: ChatMessageTypePageInfo
}

type ChatMessageTypeEdge {
  cursor: String
  node: ChatMessageType
}

type ChatMessageTypePageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

# Represents a ICE (Interactive Connectivity Establishment) configuration which is used to establish a WebRTC connection.
type IceCandidateType {
  # A DOMString describing the properties of the candidate.
  candidate: IceCandidate!

  # A DOMString which uniquely identifies the source media component from which the candidate draws data, or null if no such association exists for the candidate.
  sdpMid: String!

  # A number containing a 0-based index into the set of m-lines providing media descriptions, indicating which media source is associated with the candidate, or null if no such association is available.
  sdpMLineIndex: Int!
}

# A DOMString which describes the properties of an candidate in a WebRTC connection. It contains transport information. The syntax is described in https://datatracker.ietf.org/doc/html/rfc5245#section-15.1
scalar IceCandidate

# Represents an ICECandidate status update which provides the remote generated candidates.
type IceCandidatesStatusType {
  # The timestamp of this ice candidates status.
  timestamp: Timestamp!

  # The list of generated remote ICECandidates.
  iceCandidates: [IceCandidateType!]
}

# Represents the response of the WebRTC handshake.
type WebRtcHandshakeResponseType {
  # The id of the webrtc connection
  id: IceCandidate!

  # The SDP answer of the remote WebRTC peer.
  sdp: Sdp!
}

# A SDP (Session Description Protocol) message as standardized in https://datatracker.ietf.org/doc/html/rfc4566
scalar Sdp

# Represents execution details of a robot command.
type RobotCommandExecutionType {
  # The unique identifier of the robot command execution.
  id: ID!

  # The timestamp the command has been requested.
  startTimestamp: Timestamp!

  # The command definition which has been executed.
  opcode: RobotCommandOperationCodeEnum!

  # The context of the command execution if it exists
  contextId: String

  # The current state of the execution.
  state: RobotCommandExecutionStateEnum!

  # The result of the last execution.
  result: RobotCommandExecutionResultEnum
}

# Represents the existing robot commands. Note: not all commands are available on all robots.
enum RobotCommandOperationCodeEnum {
  # Compatibility: all robots. Set a new awake state for the robot.
  OP_CODE_AWAKE

  # Compatibility: all robots. Take a photo with a provided camera. The id of the camera is considered as the context
  OP_CODE_TAKE_PHOTO

  # Compatibility: all robots. Turn on or turn of the robots motors.
  OP_CODE_MOTOR_ENABLE

  # Compatibility: all ground robots except EXR1. Send a initial pose guess to the robot for the localization.
  OP_CODE_SET_INITIAL_ROBOT_POSE
}

# Represents the different states of a robot command execution. A command is always in one of these states.
enum RobotCommandExecutionStateEnum {
  # The command execution is 'READY' if no command execution of this type is running. A new request by a client will trigger a transition into 'REQUESTED'. It is possible that a robot triggers a direct transition into 'ACKNOWLEDGED' (e.g. the robot goes to auto sleep after the execution of a mission).
  READY

  # The command execution is 'REQUESTED' if a new command execution has been requested by an API client. If a command is in this state, it is not possible to create new execution requests of the same type until the state is 'READY' again. In the case the robot does not respond to the request, the request will timeout and will go back to 'READY'. If the robot responses to the request, a state transition to 'ACKNOWLEDGED' is performed.
  REQUESTED

  # The command execution is 'ACKNOWLEDGED' if a command request has been acknowledged by the robot. The robot tries to execute the requested command. If the execution is completed (with success or failure), a transition back to 'READY' is performed. There is also a timeout if the robot does not finish the execution within 5 minutes.
  ACKNOWLEDGED
}

# Represents the generic results of a robot command execution.
enum RobotCommandExecutionResultEnum {
  # The command execution was successful.
  SUCCEEDED

  # The command execution was excepted by the robot but the execution was not successful.
  FAILED

  # The command execution was rejected. This is typically the case if the robot does not accept the request. The execution has run into a timeout.
  REJECTED
}

# Represents a robot command execution status update for all clients
type RobotCommandExecutionStatusType {
  # The timestamp of this status
  timestamp: Timestamp!

  # The command execution
  commandExecution: RobotCommandExecutionType!
}

# Represents a robot command execution status update for all clients
type RobotCommandExecutionRequestType {
  # The unique identifier of the robot command execution.
  commandExecutionID: ID!

  # The command definition which has been executed.
  opcode: RobotCommandOperationCodeEnum!

  # The context of the command execution if it exists
  contextId: String

  # The arguments of the command.
  args: Json
}

# A unique person (either ER or customer) who currently has the right to drive the robot manually or launch autonomous missions. Multiple principal drivers are not allowed, even though multiple people can have “driver” access rights.
type PrincipalDriverType {
  # The userId of the principal driver
  userId: Float!

  # The timestamp the user got principal driver for a robot.
  timestamp: Timestamp!

  # The email address of the principal driver
  email: String!

  # The name of the principal driver
  name: String!

  # Whether or not the current user is principal driver
  isCurrentUser: Boolean!
}

type PrincipalDriversType {
  page: PrincipalDriverTypeConnection!
  pageData: PageDataType
}

type PrincipalDriverTypeConnection {
  edges: [PrincipalDriverTypeEdge!]
  pageInfo: PrincipalDriverTypePageInfo
}

type PrincipalDriverTypeEdge {
  cursor: String
  node: PrincipalDriverType
}

type PrincipalDriverTypePageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

# Robot battery type contains the statuses related to the battery.
type BatteryStatusType {
  # An estimate of the current battery percentage of the robot.
  percentage: Float!

  # The current charging state of the robot.
  chargingState: ChargingStateEnum!

  # The charger type the robot to which the robot is connected to.
  chargerType: ChargerTypeEnum!

  # The current charging current. Might be negative if the robot is discharging.
  chargingCurrent: ElectricCurrent!
}

# Represents the charging state of the robot.
enum ChargingStateEnum {
  # The robot battery is discharging. Note: depending on the charging method and the current consumption of the robot the charging state may be set to DISCHARGING, even while the robot is connected to a charger.
  DISCHARGING

  # The robot battery is charging.
  CHARGING

  # The battery is fully charged and being kept at that level by the charger.
  CHARGED
}

# Represents the charger type to which the robot is connected to. Depending on the robot type, not all of the types are available.
enum ChargerTypeEnum {
  # The robot is not connected to any charger.
  NOT_CONNECTED

  # The robot battery is charging.
  WIRED_CHARGER

  # The battery is fully charged and being kept at that level by the charger.
  WIRELESS_CHARGER
}

# An electric current is a stream of charged particles. The unit of electric current is on milliampere (mA).
scalar ElectricCurrent

# Connection status type which contains the information related to the data connection of the robot.
type ConnectionStatusType {
  # The network type that the robot is connected to.
  type: ConnectionTypeEnum!

  # The network name of carrier if the robot connected to mobile network or the SSID if the robot is connected to a WIFI network.
  networkName: String!

  # The signal strength in percentage.
  signalStrength: Float!
}

# Represents the network connection type of the robot.
enum ConnectionTypeEnum {
  # An IEEE 802.11 network.
  NET_WIFI

  # A third generation wireless mobile telecommunication network.
  NET_3G

  # A fourth generation wireless mobile telecommunication network.
  NET_4G

  # A fifth generation wireless mobile telecommunication network.
  NET_5G
}

# A Robot Status provides the temporal state of a particular robot at the specified timestamp. It provides information about the robot connection, battery, motor state and more. It is a report about the state of a robots components that could effect a mission.The status is even provided if the robot is not connected to the cloud. It also provides details about state transitions, triggered by robot commands.
type RobotStatusType {
  # The timestamp of the temporal state of the robot. This field always contains a valid value.
  timestamp: Timestamp!

  # The timestamp when the robot was last connected to the cloud (see connected). It is undefined if the robot has never been seen.
  lastSeen: Timestamp

  # Whether or not, the robot has a working wireless connection to the cloud. This field always contains a valid value. In the case connected === false, the remaining properties are invalid.
  isConnected: Boolean!

  # The current principal driver of this robot.
  principal: PrincipalDriverType

  # The awake state of the robot. This property is only valid in the case the robot is connected.
  awakeStatus: AwakeStatusEnum

  # The robot battery status contains the statuses related to the battery. This property is only valid in the case the robot is connected.
  batteryStatus: BatteryStatusType

  # The connection status type contains the statuses related to the data connection of the robot. This property is only valid in the case the robot is connected.
  connectionStatus: ConnectionStatusType

  # The emergency switch has been pressed. The robot is unable to move. This property is only valid in the case the robot is connected.
  isEmergencySwitchPressed: Boolean

  # The motors of the robot are enabled. The availability of this option depends on the robot type (if not the value is always true). The robot is only able to move if the motors are enabled. This property is only valid in the case the robot is connected.
  isMotorsEnabled: Boolean

  # Indicate whether or not the robot is in the docking station.
  isDocking: Boolean
}

# Represents the sleep status of the robot. It consists of two primary states: AWAKE and ASLEEP. The transitions between the two are usually not applied instantaneously. During this time, the sleep state is in an intermediate state.
enum AwakeStatusEnum {
  # The robot is fully available. This state is mandatory to perform actions on the robot or get access to sensor data (e.g. camera images). In this state, the robot has larger battery consumption even if the robot does not executes any tasks.
  AWAKE

  # In this state, the robot is in a low-power mode. It is still connected to the cloud and publishes its status but at a significantly lower frequency. It is also possible to wake the robot up remotely. All other consumers are shut down.
  ASLEEP

  # The transition state from 'ASLEEP' to 'AWAKE'.
  WAKING_UP

  # The transition state from 'AWAKE' to 'ASLEEP'.
  GOING_TO_SLEEP
}

# Represents a pair of an robot id and a corresponding robot status
type StatusPerRobotType {
  # The robot id of the robot which produces the status.
  robotID: ID!

  # The status of the robot.
  status: RobotStatusType!
}

# Represents the status of the principal driver of a robot.
type PrincipalDriverStatusType {
  # The timestamp of this principal driver status.
  timestamp: Timestamp!

  # The current principal driver.
  principal: PrincipalDriverType
}

# Represents a single human robot supervisor session.
type HumanRobotSupervisorSessionType {
  # The start date of the session
  startTimestamp: Timestamp!

  # The end timestamp of the session. If it is set the session is considered as closed.
  endTimestamp: Timestamp

  # The responsible human supervisor
  supervisor: UserType!

  # Represents the acknowledgement state of the principal driver regarding the supervisor session.
  acknowledgementState: HumanRobotSupervisorAcknowledgementStateEnum!
}

# Represents acknowledgement of a principal driver in a human robot supervisor session.
enum HumanRobotSupervisorAcknowledgementStateEnum {
  # There is not an answer from the principal driver yet.
  NOT_ANSWERED

  # The principal driver accepted the takeover request of the human robot supervisor
  ACCEPTED

  # The principal driver declined the takeover request of the human robot supervisor
  DECLINED
}

# Represents the status of a human robot supervisor session.
type HumanRobotSupervisorSessionStatusType {
  # The timestamp of this human robot supervisor session status.
  timestamp: Timestamp!

  # The current robot assistant session.
  session: HumanRobotSupervisorSessionType
}

# Represents the scope of an event.
type EventScopeType {
  # The type of the scope.
  type: EventScopeTypeEnum!

  # In case of type 'SITE', the specific site the event is associated with.
  siteId: String

  # In case of type 'ROBOT', the specific robot the event is associated with.
  robotId: String
}

# The different types of event scopes.
enum EventScopeTypeEnum {
  # The event is related to the overall system.
  SYSTEM

  # The event is related to a site.
  SITE

  # The event is related to a robot.
  ROBOT
}

# Represents a single diagnostic message
type DiagnosticsType {
  # The timestamp the event happens.
  timestamp: Timestamp!

  # The type/level of this message. This might be an hint how critical the message is.
  type: DiagnosticsTypeEnum!

  # The component which has generated the diagnostic message.
  component: String

  # The diagnostic key.
  value: String!
}

# Represents the type of a single diagnostic message.
enum DiagnosticsTypeEnum {
  # The message represents an information to the user.
  INFO

  # The message represents an warning to the user.
  WARNING

  # The message represents an error to the user.
  ERROR
}

# Represents a generic event in the ER GraphQL API.
type EventType {
  # The id of the event.
  id: String!

  # The timestamp of the event.
  timestamp: Timestamp!

  # The scope of the event (e.g. a specific robot or site).
  scope: EventScopeType!

  # The diagnostics describing the event.
  diagnostics: [DiagnosticsType!]!
}

# Represents a mission execution control request by the Cloud Core API (triggered by the user interface or the API directly) to a particular robot.
type MissionExecutionControlRequestType {
  # The mission execution this request is associated with. It may be used by the robot to send processes ans status updates.
  missionExecutionID: ID!

  # The mission control action which has been requested. Depending on the value other fields are available or not.
  action: MissionExecutionControlActionEnum!

  # Available if: action in ['START', 'GO_TO_TASK']. The mission definition which should be executed by the robot.
  missionDefinition: MissionDefinitionType

  # Available if: action in ['GO_TO_TASK']. The mission status before the request.
  previousStatus: MissionExecutionStatusEnum

  # Available if: action in ['GO_TO_TASK']. The mission task definition which should be the next executed task.
  nextMissionTaskDefinitionId: String
}

# Represents the mission execution control action, which is used to send user command requests to the robot
enum MissionExecutionControlActionEnum {
  # Represents a request to start or resume  a mission
  START

  # Represents a request to pause a mission.
  PAUSE

  # Represents a request to set the next executed task to a provided one.
  GO_TO_TASK
}

# Represents the status of a mission execution.
enum MissionExecutionStatusEnum {
  # The mission execution is "START_REQUESTED" if a request for a new mission execution has been sent to the robot.
  START_REQUESTED

  # The mission execution is "PAUSE_REQUESTED" if an request has been sent to the robot to pause the mission.
  PAUSE_REQUESTED

  # The mission execution is "RESUME_REQUESTED" if an request has been sent to the robot to resume the mission.
  RESUME_REQUESTED

  # The mission execution is "GO_TO_TASK_REQUESTED" if an request has been sent to the robot to go to a desired task.
  GO_TO_TASK_REQUESTED

  # The mission execution is "REJECTED" if something went wrong during the mission execution command.
  REJECTED
    @deprecated(
      reason: "The robot should send its actual state instead of rejecting a request."
    )

  # The mission execution is "WAKING_UP" if the robot is still in sleep mode and needs to be waken up before executing the mission.
  WAKING_UP

  # The mission execution is "STARTING" if the robot has acknowledged the request and prepared the mission execution. (e.g. waking up the robot, enabling motors and sensors etc.)
  STARTING

  # The mission execution is "IN_PROGRESS" if the mission is currently running.
  IN_PROGRESS

  # The mission execution is "PAUSED" if the mission has been interrupted either by the user or by an anomaly.
  PAUSED

  # The mission execution has been "COMPLETED" if the mission execution is completed. This is usually the case if the robot has been returned to the docking station.
  COMPLETED
}

# Represents the online data of an executed mission by a particular robot (Not to be confused with the mission report, which represents a persistent data of a mission execution.).
type MissionExecutionType {
  # The unique identifier of the mission execution.
  id: ID!

  # The timestamp the mission execution has started.
  startTimestamp: Timestamp!

  # The current control mode during the mission.
  controlMode: ControlModeEnum!

  # The status, of the mission execution.
  status: MissionExecutionStatusEnum!

  # In the case the mission has been paused unexpectedly: The occurred failures.
  failures: [MissionExecutionFailureEnum!]!

  # The mission definition which has been selected.
  missionDefinition: MissionDefinitionType

  # The id of the task definition which is currently executed.
  currentExecutedTaskId: String
}

# Represents the control mode of the robot.
enum ControlModeEnum {
  # The robot is controlled manually by a user with driver access.
  MANUAL

  # The robot autonomously executes a mission.
  AUTONOMOUS

  # The robot has been stopped and is not being controlled at the moment (e.g. is located in the docking station).
  STOPPED
}

# Represents failures which might occur during a mission execution.
enum MissionExecutionFailureEnum {
  # A stop tag has been detected.
  MISSION_FAILURE_STOP_TAG

  # The robot has lost the line.
  MISSION_FAILURE_LINE_LOST

  # The wired quick charger is still connected.
  MISSION_FAILURE_QUICK_CHARGER_CONNECTED

  # The emergency stop is still pressed.
  MISSION_FAILURE_ESTOP_PRESSED

  # Nobody is supervising the robot.
  MISSION_FAILURE_WATCHDOG_LOST

  # A sensor value is above the maximum threshold.
  MISSION_FAILURE_SENSOR_LEVEL_ABOVE_THRESHOLD

  # A sensor value is below the minimum threshold.
  MISSION_FAILURE_SENSOR_LEVEL_BELOW_THRESHOLD

  # The battery level is to low to continue the mission.
  MISSION_FAILURE_LOW_BATTERY

  # The robot detected a potential collision with an obstacle.
  MISSION_FAILURE_COLLISION_DETECTED

  # An failure which cannot identified has been accrued during the mission execution.
  MISSION_FAILURE_UNKNOWN

  # An failure which cannot identified has been accrued
  UNKNOWN
    @deprecated(
      reason: "Changed convention, use 'MISSION_FAILURE_UNKNOWN' instead."
    )
}

# Represents the status of the mission execution of a robot.
type MissionExecutionStatusType {
  # The timestamp of this mission execution status.
  timestamp: Timestamp!

  # The current executed mission. If no mission is running null is provided.
  missionExecution: MissionExecutionType
}

# Represents the subscription type of a trajectory.
type TrajectorySubscriptionType {
  # The timestamp of the trajectory.
  timestamp: Timestamp!

  # The trajectory data.
  trajectory: [Pose3DStampedType!]!
}

# Represents the snapshot of a mission execution.
type MissionExecutionSnapshotType {
  # The unique identifier of the site.
  site: String!

  # The unique identifier of the robot snapshot.
  robotSnapshotId: String!

  # The timestamp of this mission execution snapshot.
  timestamp: Timestamp!

  # The current mission execution status.
  executionStatus: MissionExecutionStatusEnum!

  # The unique identifier of the mission definition.
  missionDefinitionId: String!
}

# The recorded data is an image. Typically it is stored as a PNG.
type PhotoDataPayloadType implements AbstractDataPayloadType {
  # The unique identifier of this payload.
  id: ID!

  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The type of this payload.
  dataType: DataPayloadTypeEnum!

  # The producer of this payload. Can be null for Energy Robotics.
  producer: DataPayloadProducerType

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # (For future use, currently always null) The region of interest on the site were the data has been recorded. It has been either a point of interest or an area of interest.
  regionOfInterest: RegionOfInterestUnion

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean!

  # The timestamp the data has been generated.
  timestamp: Timestamp!

  # The uri to access the photo.
  uri: Uri!
}

# The recorded payload is an audio file. Typically it is stored in the WEBM format.
type AudioDataPayloadType implements AbstractDataPayloadType {
  # The unique identifier of this payload.
  id: ID!

  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The type of this payload.
  dataType: DataPayloadTypeEnum!

  # The producer of this payload. Can be null for Energy Robotics.
  producer: DataPayloadProducerType

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # (For future use, currently always null) The region of interest on the site were the data has been recorded. It has been either a point of interest or an area of interest.
  regionOfInterest: RegionOfInterestUnion

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean!

  # The start timestamp of the audio file.
  fromTimestamp: Timestamp!

  # The end timestamp of the audio file.
  toTimestamp: Timestamp!

  # The uri to access the audio file. (Currently only the filename is provided.)
  uri: Uri!
}

# The recorded payload is an video file. Typically it is stored in the MP4 format using H.264 encoding.
type VideoDataPayloadType implements AbstractDataPayloadType {
  # The unique identifier of this payload.
  id: ID!

  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The type of this payload.
  dataType: DataPayloadTypeEnum!

  # The producer of this payload. Can be null for Energy Robotics.
  producer: DataPayloadProducerType

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # (For future use, currently always null) The region of interest on the site were the data has been recorded. It has been either a point of interest or an area of interest.
  regionOfInterest: RegionOfInterestUnion

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean!

  # The start timestamp of the video file.
  fromTimestamp: Timestamp!

  # The end timestamp of the video file.
  toTimestamp: Timestamp!

  # The uri to access the audio file.
  uri: Uri!
}

# The recorded payload has the form of a 1D time series. This means we have have a discrete series of timestamps. For every timestamp we have a corresponding scalar value (e.g. temperature measurements).
type TimeSeries1DDataType {
  # The name of the data series.
  timestamp: Timestamp!

  # The position of the robot during the recording of this entry
  position: Point3DType!

  # The distance which has been traveled to this measurement point.
  distanceTraveled: Float!

  # The measured value.
  value: Float
}

# Represents a 1D timestamped data series.
type TimeSeries1DDataPayloadType implements AbstractDataPayloadType {
  # The unique identifier of this payload.
  id: ID!

  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The type of this payload.
  dataType: DataPayloadTypeEnum!

  # The producer of this payload. Can be null for Energy Robotics.
  producer: DataPayloadProducerType

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # (For future use, currently always null) The region of interest on the site were the data has been recorded. It has been either a point of interest or an area of interest.
  regionOfInterest: RegionOfInterestUnion

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean!

  # The name of the data series.
  name: String!

  # The unit of the data entries.
  unit: String!

  # The time series data.
  data: [TimeSeries1DDataType!]!
}

# Represents superset of the PHOTO type but with the option to render (multiple) svg based overlays on top of it.
type PhotoOverlayDataPayloadType implements AbstractDataPayloadType {
  # The unique identifier of this payload.
  id: ID!

  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The type of this payload.
  dataType: DataPayloadTypeEnum!

  # The producer of this payload. Can be null for Energy Robotics.
  producer: DataPayloadProducerType

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # (For future use, currently always null) The region of interest on the site were the data has been recorded. It has been either a point of interest or an area of interest.
  regionOfInterest: RegionOfInterestUnion

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean!

  # The timestamp the image has been created.
  timestamp: Timestamp!

  # The uri to access the photo.
  uri: Uri!

  # The overlay (e.g. an SVG) that can be rendered on top of the photo.
  overlayUri: Uri!
}

# Represents a single data accessor which allows a skill provider to highlight important fields in the json data.
type JSONDataAccessorType {
  # A human readable name of the data field.
  name: String!

  # A key accessor in dot notation. (e.g. jsonData.subfield.subsubfield).
  accessor: String!
}

# Represents the recorded data in a JSON structure. The schema is defined by the data producer. Typically the producer is a skill.
type JSONDataPayloadType implements AbstractDataPayloadType {
  # The unique identifier of this payload.
  id: ID!

  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The type of this payload.
  dataType: DataPayloadTypeEnum!

  # The producer of this payload. Can be null for Energy Robotics.
  producer: DataPayloadProducerType

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # (For future use, currently always null) The region of interest on the site were the data has been recorded. It has been either a point of interest or an area of interest.
  regionOfInterest: RegionOfInterestUnion

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean!

  # The JSON data structure.
  jsonData: Json!

  # Data accessors to highlight important fields in the jsonData field.
  dataAccessors: [JSONDataAccessorType!]
}

# Represents a composite type to group multiple payloads together.
type GroupDataPayloadType implements AbstractDataPayloadType {
  # The unique identifier of this payload.
  id: ID!

  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The type of this payload.
  dataType: DataPayloadTypeEnum!

  # The producer of this payload. Can be null for Energy Robotics.
  producer: DataPayloadProducerType

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # (For future use, currently always null) The region of interest on the site were the data has been recorded. It has been either a point of interest or an area of interest.
  regionOfInterest: RegionOfInterestUnion

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean!

  # The data payloads of this group.
  group: [AbstractDataPayloadType!]!
}

# Represents the description of the producer e.g. skill which has generated the payload data.
type DataPayloadProducerType {
  # An dot seperated identifier that groups skills of the same provider. E.g.: com.energy-robotics
  group: String!

  # A human readable name of the skill that produced the payload.
  name: String!
}

# Represents the paginated type of the AbstractDataPayload
type AbstractDataPayloadsType {
  page: AbstractDataPayloadTypeConnection!
  pageData: PageDataType
}

type AbstractDataPayloadTypeConnection {
  edges: [AbstractDataPayloadTypeEdge!]
  pageInfo: AbstractDataPayloadTypePageInfo
}

type AbstractDataPayloadTypeEdge {
  cursor: String
  node: AbstractDataPayloadType
}

type AbstractDataPayloadTypePageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

# Represents the subscription type for a data payload.
type DataPayloadSubscriptionType {
  # The timestamp of this subscription message.
  timestamp: Timestamp!

  # If true, the data payloads was already available and has been updated
  updated: Boolean!

  # The data payload
  dataPayload: AbstractDataPayloadType!
}

# Represents a copy of a subset of the mission definition. It is used to store the relevant information in the mission report. This data is still available even if the original mission has been removed or modified.
type MissionDefinitionSnapshotType {
  # The legacy mission definition id.
  legacyMissionDefinitionId: String
    @deprecated(
      reason: "This field is only available to keep compatibility with a legacy system. It will be removed in the future."
    )

  # A human-readable name of the mission.
  name: String!
}

# A mission report holds all the data of an particular mission execution (The time between undocking and docking of the robot.). The report has references to all inspection data recorded during the mission. It also stores metadata from the actual execution.
type MissionReportType {
  # The unique identifier of the mission report.
  id: ID!

  # An external provided uuid to re-identify the mission report (e.g. to prevent duplicates).
  key: String!

  # The start timestamp of the mission execution.
  startTimestamp: Timestamp!

  # The end timestamp of the mission execution.
  endTimestamp: Timestamp

  # The specific robot snapshot, which has executed the mission. The exact configuration of the robot during the mission is preserved even if the robot configuration changes in the future or removed from the site.
  robot: RobotSnapshotType!

  # The diagnostics e.g. errors and warnings which occurred during the mission.
  diagnostics: [DiagnosticsType!]!

  # The trajectory driven by the robot during this mission.
  trajectory: [Pose3DStampedType!]

  # The distance driven by the robot during the mission.
  distance: Distance

  # The duration of the mission execution.
  duration: Duration

  # The mission definitions used during this mission executions. If the array is empty than the mission has been executed fully in teleportation mode.
  missionDefinitions: [MissionDefinitionSnapshotType!]!

  # All the data payloads recorded the mission. It does not matter if it was part of a planned mission or manual taken, or if the data has been generated during postprocessing by a skill.
  dataPayloads: [AbstractDataPayloadType!]
}

# Distance is a numerical measurement of how far apart objects or points are. The unit of distance is on "Meter" (m).
scalar Distance

# The `Duration` scalar type represents a length of time in milliseconds. The data is provided as a number.
scalar Duration

# Subset of the mission report type. It does not include large data property like the 'trajectory' or the 'dataPayloads'. In order to retrieve this data query the specific report explicitly.
type MissionReportOverviewType {
  # The unique identifier of the mission report.
  id: ID!

  # An external provided uuid to re-identify the mission report (e.g. to prevent duplicates).
  key: String!

  # The start timestamp of the mission execution.
  startTimestamp: Timestamp!

  # The end timestamp of the mission execution.
  endTimestamp: Timestamp
  robot: RobotSnapshotType!

  # The diagnostics e.g. errors and warnings which occurred during the mission.
  diagnostics: [DiagnosticsType!]!

  # The distance driven by the robot during the mission.
  distance: Distance

  # The duration of the mission execution.
  duration: Duration

  # The mission definitions used during this mission executions. If the array is empty than the mission has been executed fully in teleportation mode.
  missionDefinitions: [MissionDefinitionSnapshotType!]!
}

type MissionReportsType {
  page: MissionReportOverviewTypeConnection!
  pageData: PageDataType
}

type MissionReportOverviewTypeConnection {
  edges: [MissionReportOverviewTypeEdge!]
  pageInfo: MissionReportOverviewTypePageInfo
}

type MissionReportOverviewTypeEdge {
  cursor: String
  node: MissionReportOverviewType
}

type MissionReportOverviewTypePageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

# Represents the subscription type for a mission report.
type MissionReportSubscriptionType {
  # The timestamp of this subscription message.
  timestamp: Timestamp!

  # If true, the mission report was already available and has been updated
  updated: Boolean!

  # The mission report.
  missionReport: MissionReportType!
}

type Query {
  # Request the current api version.
  currentApiVersion: String!

  # Request the list of sites, the logged in user has access to.
  sites: [SiteType!]!

  # Request a desired site, the logged in user has access to.
  site(
    # The ID of the requested site.
    id: String!
  ): SiteType!

  # Request a desired site by its site number.
  siteByNumber(
    # The number of the requested site.
    number: Float!
  ): SiteType!

  # Request the robot fleet. It consists of all robots from all sites the user has access to.
  robotFleet(
    # Optional filter parameter: It allows to filter the robot fleet by different criteria. If it is not provided, the full fleet is returned.
    input: QueryRobotsInput
  ): [RobotType!]!

  # Request the robot info of a specific robot.
  robot(
    # The ID of the requested robot.
    id: String!
  ): RobotType!

  # Request the robot info of a specific robot.
  robotByNumber(
    # The number of the requested robot.
    number: Int!
  ): RobotType!

  # Request all available robot types of the requesting user.
  robotTypes: [RobotTypeEnum!]!

  # @Private Get the current open site stage
  currentSiteStage(
    # The id of the site
    siteId: String!
  ): SiteStageType

  # @Private Get a page of site snapshots of a selected site
  siteSnapshots(
    # The pagination parameters.
    filter: ConnectionInput

    # The id of the site
    siteId: String!
  ): SiteSnapshotsType!

  # @Private Get the current head snapshot of a site. The head is the snapshot the current site configuration is based on
  currentSiteSnapshotHead(
    # The id of the site
    siteId: String!
  ): SiteSnapshotType!

  # @Private Request the list of all existing points of interest the user has access to. If you are interested in the POIs of a specific site please take a look at the 'pointsOfInterest' property of the site.
  pointsOfInterest: [PointOfInterestType!]!
    @deprecated(
      reason: "[06.12.2022] Please use the field 'pointsOfInterest' in type 'SiteType' instead"
    )

  # Request a specific area of interest.
  pointOfInterest(
    # The ID of the requested area of interest.
    id: String!
  ): PointOfInterestType!

  # Request the list of all existing area of interest the user has access to. If you are interested in the AOIs of a specific site please take a look at the 'areasOfInterest' property of the site.
  areasOfInterest: [AreaOfInterestType!]!

  # Request a specific area of interest.
  areaOfInterest(
    # The ID of the requested area of interest.
    id: String!
  ): AreaOfInterestType!

  # Request the current user.
  currentUser: UserType!

  # Request all available robot urdfs of the requesting user.
  robotURDFs: [Urdf!]!
    @deprecated(reason: "[10.11.2022] unify naming  Use 'robotUrdfs' instead")

  # Request all available robot urdfs of the requesting user.
  robotUrdfs: [Urdf!]!

  # @Private Get a current site recording if available
  currentSiteRecording(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType

  # Request the list of mission definitions
  missionDefinitions(
    # Define the filter criteria. At least one of them has to be provided.
    input: QueryMissionDefinitionInput!
  ): [MissionDefinitionsType!]!

  # Request a specific of mission definition.
  missionDefinition(
    # The id of the requested mission definition.
    id: String!
  ): MissionDefinitionType!

  # @Internal Request mission definition id for a provided legacy mission definition id and roboto id.
  missionDefinitionIdByLegacyMission(
    # The legacy id of the requested mission definition.
    legacyMissionDefinitionId: String!

    # The id of the robot the legacy mission is trained for.
    robotId: String!

    # The id of the site the mission definition belongs to.
    siteId: String!
  ): String!

  # @Internal Request the roadmap of a specified mission definition and robot.
  currentMissionRoadmap(
    # The id of the requested mission definition.
    robotId: String!

    # The id of the requested mission definition.
    missionDefinitionId: String!
  ): MissionRoadmapType!

  # @Private Find all task definitions.
  missionTaskDefinitions: [AbstractMissionTaskDefinitionType!]!

  # @Private Receive a robots' current grid map which is used by the path planner.
  gridMapForRobot(
    # The ID of the requested robot.
    robotId: String!
  ): GridMapType!

  # @Private Get the chat history of a particular robot. The messages are ordered by timestamp in descending order
  robotChatHistory(
    # The pagination parameters
    filter: ConnectionInput!

    # The id of the robot
    robotId: String!
  ): ChatMessagesType!

  # @Private Provides the current human robot supervisor session for a robot if available
  humanRobotSupervisorSessionForRobot(
    # The id of the robot.
    robotId: String!
  ): HumanRobotSupervisorSessionType

  # @Internal Get all principal drivers for a robot ordered by time in descending order.
  principalDrivers(
    # The id of the robot.
    robotId: String!

    # The pagination parameters.
    filter: ConnectionInput
  ): PrincipalDriversType

  # @Private Get the current principal driver for a robot.
  currentPrincipalDriver(
    # The id of the robot.
    robotId: String!
  ): PrincipalDriverType

  # @Private Get the principal driver at a given timestamp for a robot.
  principalDriverAtTimestamp(
    # The id of the robot.
    timestamp: Timestamp!

    # The id of the robot.
    robotId: String!
  ): PrincipalDriverType

  # @Private Check if the current user is principal driver of a robot.
  isPrincipalDriver(
    # The id of the robot.
    robotId: String!
  ): Boolean!

  # Get to the latest robot status for a given robot. In order to receive status updates subscribe to "onRobotStatus".
  currentRobotStatus(
    # The id of the robot the status should requested from.
    robotID: String!
  ): RobotStatusType!

  # Get to the latest robot statuses for a selection of robots. In order to receive status updates subscribe to "onRobotStatuses".
  currentRobotStatuses(
    # The ids of the robots the status should requested from.
    robotIDs: [String!]!
  ): [StatusPerRobotType!]!

  # Get to the latest robot statuses for all accessible robots from a site. In order to receive status updates subscribe to "onRobotStatusesPerSite".
  currentRobotStatusesPerSite(
    # The id of the site the current status should requested from.
    siteID: String!
  ): [StatusPerRobotType!]!

  # Receive the current executed mission for a specific robot. If no mission is running "null" is returned
  currentMissionExecution(
    # The id of the robot.
    robotID: String!
  ): MissionExecutionType

  # Check weather or not a mission is running for a specific robot.
  isMissionRunning(
    # The id of the robot.
    robotID: String!
  ): Boolean!

  # @Internal Receive a list of mission execution snapshots of a specific robot for a specified period.
  missionExecutionSnapshots(
    # The period in which the snapshots are taken.
    period: PeriodInput!

    # The number of the robot.
    robotNumber: Float!

    # The id of the site.
    site: String!
  ): [MissionExecutionSnapshotType!]!

  # Receive the history of executed missions. The list is sorted in descending order by the start timestamp. Note that the the list only provides a lightweight subset of the reports. In order to receive the full report (e.g. payloads, trajectory data, ...) query the specific report by id.
  missionReports(
    # The filter parameters. At least one needs to be provided.
    input: QueryMissionReportInput!

    # The pagination parameters.
    filter: ConnectionInput
  ): MissionReportsType!

  # Receive a specific mission report.
  missionReport(
    # The ID of the desired mission report.
    id: String!
  ): MissionReportType!

  # @Internal Receive a specific mission report by key.
  missionReportByKey(
    # The key of the desired mission report.
    key: String!
  ): MissionReportType!

  # Find all available payloads recorded by a certain robot.
  dataPayloadsByRobot(
    # The pagination parameters.
    filter: ConnectionInput!

    # The query parameters.
    input: QueryDataPayloadsByRobotInput!
  ): AbstractDataPayloadsType!

  # @Internal Find all available payloads recorded at a specific point of interest.
  dataPayloadsByPointOfInterest(
    # The pagination parameters.
    filter: ConnectionInput

    # The id of the interested point of interest
    pointOfInterestId: String!
  ): AbstractDataPayloadsType!

  # Find a specific payload.
  dataPayload(
    # The id of the data payload
    id: String!
  ): AbstractDataPayloadType!

  # Find a specific payload by key.
  dataPayloadForKey(
    # The key of the payload
    key: String!
  ): AbstractDataPayloadType!

  # Find all payloads involved by a particular skill execution.
  dataPayloadsBySkillExecution(
    # The parameters which identify the interested skill execution.
    input: QueryDataPayloadsBySkillExecutionInput!
  ): [AbstractDataPayloadType!]!
}

# This input may be used to apply filters to the robot fleet query. The filter criteria are applied as conjunctions. Each filter criterion is optional.
input QueryRobotsInput {
  # @deprecated: [10.11.2022] unify naming, Filter the list, to robots located on a provided site.
  siteID: String

  # Filter the list, to robots located on a provided site.
  siteId: String
}

input ConnectionInput {
  # Paginate before opaque cursor.
  before: String

  # Paginate after opaque cursor.
  after: String

  # Paginate first.
  first: Float

  # Paginate last.
  last: Float
}

# Query options for mission definition queries.
input QueryMissionDefinitionInput {
  # Query for mission definitions defined on a specific site.
  siteID: String

  # Query for mission definitions executable by a specific robot.
  robotID: String
}

input PeriodInput {
  # The start date.
  start: Timestamp!

  # The end date.
  end: Timestamp!
}

# This input may be used to apply filters to the mission report query. The filter criteria are applied as conjunctions. Each filter criterion is optional but at least on needs to be provided!
input QueryMissionReportInput {
  # Provide mission reports generated on a specific site.
  siteId: String

  # Provide mission reports generated by a list of robot snapshots.
  robotSnapshotIds: [String!] = []

  # Provide mission reports generated by a robot with a certain robot number.
  robotNumber: Float

  # Provide mission reports generated by a specific robot. Please notice: This option requires at least viewer access to the robot.
  robotId: String
}

# Parameters to query data payloads by robot
input QueryDataPayloadsByRobotInput {
  # Provide data payloads generated by a robot with a provided robot id.
  robotId: String

  # Provide data payloads generated by a robot with a provided robot number.
  robotNumber: Int

  # Provide data payloads generated by a list of robot snapshots.
  robotSnapshotIds: [String!] = []

  # Specify the payload types which should be considered. If this parameter is not set all types are considered.
  types: [DataPayloadTypeEnum!]
}

# Parameters to query data payloads by skill execution details.
input QueryDataPayloadsBySkillExecutionInput {
  # The key of the parent payload, the skill has been executed on.
  parentPayloadKey: String!

  # The group of the skill.
  producerGroup: String!

  # The name of the skill.
  producerName: String!
}

type Mutation {
  # Apply updates to an existing site.
  updateSite(
    # The changes which should be applied.
    input: UpdateSiteInput!

    # The site id.
    id: String!
  ): SiteType!

  # @Private Apply updates to an existing site.
  updateSiteSensorConfigLimits(
    input: SiteSensorConfigLimitInput!

    # The abbreviation of the measured physical phenomenon.
    abbreviation: String!

    # The site id.
    siteId: String!
  ): SiteType!

  # @Private Apply updates to an existing site.
  removeSiteSensorConfig(
    # The abbreviation of the measured physical phenomenon.
    abbreviation: String!

    # The site id.
    siteId: String!
  ): SiteType!

  # @Private Apply updates to an existing site.
  removeSiteSensorConfigLimit(
    # The limit tag.
    tags: [String!]!

    # The abbreviation of the measured physical phenomenon.
    abbreviation: String!

    # The site id.
    siteId: String!
  ): SiteType!

  # Update an existing point cloud configuration.
  updatePointCloudConfig(
    input: UpdateSitePointCloudConfigInput!

    # The id of the requested site.
    id: String!
  ): SiteType!

  # @Internal
  createSite(input: CreateSiteInput!): SiteType!

  # @Internal
  addRobotToSite(robotID: String!, id: String!): SiteType!

  # @Internal
  updateRobotSite(robotID: String!, id: String!): SiteType!

  # @Internal
  removeRobotFromSite(robotID: String!, id: String!): SiteType!

  # @Internal Add (or override) a point configuration to specific site.
  addPointCloudConfig(
    input: AddSitePointCloudConfigInput!

    # The id of the requested site.
    id: String!
  ): SiteType!

  # @Internal
  deleteSite(
    # The id of the requested site.
    id: String!
  ): SiteType!

  # @Internal
  recoverSite(
    # The id of the requested site.
    id: String!
  ): SiteType!

  # @Internal Create a new robot
  createRobot(input: CreateRobotInput!): RobotType!

  # @Private Create a new stage for a site. At the moment only one simultaneous stage is supported
  openSiteStage(
    # The id of the site
    siteId: String!
  ): SiteStageType!

  # @Private Discard an existing site stage. The changes are not committed.
  discardSiteStage(
    # The id of the affected site stage
    siteStageId: String!
  ): SiteStageType!

  # @Private Add a point of interest to a stage.
  addPointOfInterestToStage(
    # The id of the affected site stage
    pointOfInterestId: String!

    # The id of the affected site stage
    siteStageId: String!
  ): SiteStageType!

  # @Private Add a site object to a stage.
  addSiteObjectToStage(
    # The id of the affected site stage
    siteObjectId: String!

    # The id of the affected site stage
    siteStageId: String!
  ): SiteStageType!

  # @Private Commit an open stage and create a new site snapshot
  commitSiteChanges(
    # The id of the stage that should be committed
    siteStageId: String!
  ): SiteSnapshotType!

  # @Private Change the current snapshot used for the site. This changes the current site to the snapshot state.
  selectCurrentSiteSnapshotHead(
    # The id of the site snapshot
    siteSnapshotId: String!

    # The id of affected site
    siteId: String!
  ): SiteSnapshotType!

  # @Private Set the current head the initial state to reset the site.
  resetToInitialSiteSnapshot(
    # The id of affected site
    siteId: String!
  ): SiteSnapshotType!

  # @Private Request a specific area of interest.
  addPointOfInterest(input: AddPointOfInterestInput!): PointOfInterestType!

  # @Private
  upsertPointOfInterest(
    input: UpsertPointOfInterestInput!
  ): PointOfInterestType!

  # @Internal
  updatePointOfInterest(
    input: UpdatePointOfInterestInput!

    # The id of the requested point of interest.
    id: String!
  ): PointOfInterestType!

  # @Internal Deletes all point of interest of a provided site.
  deleteAllPointOfInterestForSite(
    # The site which should be considered
    siteId: String!
  ): Int!

  # @Internal
  createAreaOfInterest(input: CreateAreaOfInterestInput!): AreaOfInterestType!

  # @Private Create or update a docking station site object.
  upsertDockingStationSiteObject(
    input: CreateDockingStationSiteObjectInput!

    # The id of the site.
    siteId: String!
  ): DockingStationSiteObjectType!

  # @Internal Deletes all site objects of a provided site.
  deleteAllSiteObjectsForSite(
    # The site which should be considered
    siteId: String!
  ): Int!

  # @Private Update the accent color for a specific robot in the user interface.
  updateRobotColor(
    # The new color.
    color: Color

    # The id of the requested robot.
    robotId: String!
  ): RobotConfigType!

  # @Internal Update the URDF for a specific robot.
  updateURDF(
    # The new URDF.
    urdf: Urdf!

    # The id of the requested robot.
    id: String!
  ): RobotType!
    @deprecated(
      reason: "[10.11.2022] unify naming and change return type.  Use 'updateUrdf' instead"
    )

  # @Internal Update the URDF for a specific robot.
  updateUrdf(
    # The new URDF.
    urdf: Urdf!

    # The id of the requested robot.
    robotId: String!
  ): RobotConfigType!

  # @Internal Add a new camera description to a robot
  addCameraDescription(
    input: AddCameraDescriptionInput!

    # The id of the requested robot
    robotId: String!
  ): CameraConfigType!

  # @Internal Remove an existing camera description from a robot
  removeCameraDescription(
    # The id of the camera description which should be removed
    cameraDescriptionId: String!

    # The id of the requested robot
    robotId: String!
  ): CameraConfigType!

  # @Internal Set the default inspection cam of the robot
  setDefaultInspectionCamera(
    # The id of the camera description which should be set as default inspection cam
    cameraDescriptionId: String!

    # The id of the requested robot
    robotId: String!
  ): CameraConfigType!

  # @Internal Set the default driving cam of the robot
  setDefaultDrivingCamera(
    # The id of the camera description which should be set as default driving cam.
    cameraDescriptionId: String!

    # The id of the requested robot.
    robotId: String!
  ): CameraConfigType!

  # @Internal Add a new sensor configuration to a robot
  addSensorDescription(
    # The payload to add a new sensor config
    input: AddSensorDescriptionInput!

    # The id of the requested robot
    robotId: String!
  ): SensorConfigType!

  # @Internal Remove an existing sensor description from the robot
  removeSensorDescription(
    # The id of the sensor description
    sensorDescriptionId: String!

    # The id of the requested robot
    robotId: String!
  ): SensorConfigType!

  # @Internal
  reorderSensorDescription(
    # The target index of the selected description in [0, length)
    targetIndex: Int!

    # The id of the sensor description
    sensorDescriptionId: String!

    # The id of the requested robot
    robotId: String!
  ): SensorConfigType!

  # @Internal Update an existing sensor description
  updateSensorDescription(
    # The payload to update an existing sensor config
    input: UpdateSensorDescriptionInput!

    # The id of the sensor description
    sensorDescriptionId: String!

    # The id of the requested robot
    robotId: String!
  ): SensorConfigType!

  # @Private Start a new site recording with a provided robot
  startSiteRecording(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Private Stop a site recording for a robot
  stopSiteRecording(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Private Decline a site recording for a robot
  declineSiteRecording(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Internal Signal by the robot to accept the start recording request
  acceptedStartSiteRecordingRequest(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Internal Signal by the robot to signalize the start of the recording
  startedSiteRecording(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Internal Signal by the robot to accept the stop recording request
  acceptedStopSiteRecordingRequest(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Internal Signal by the robot to signalize the stop of the recording
  stoppedSiteRecording(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Internal Signal by the robot to accept the decline recording request
  acceptedDeclineSiteRecordingRequest(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Internal Signal by the robot to signalize the decline of the recording
  declinedSiteRecording(
    # The id of the robot
    robotId: String!
  ): SiteRecordingType!

  # @Internal Create a new snapshot of the robot. This has to be done after the configuration of the robot has been completed and/or the robot moved to a different site.
  createRobotSnapshot(
    # The id of the robot which should be snapshotted
    robotId: String!
  ): RobotSnapshotType!

  # @Private Create a new mission definition.
  createMissionDefinition(
    # The properties of the new mission.
    input: CreateMissionDefinitionInput!
  ): MissionDefinitionType!

  # @Private Rename an existing mission definition.
  renameMissionDefinition(
    # The new (non empty) name of the mission definition
    name: String!

    # The mission definition id which should be renamed.
    missionDefinitionId: String!
  ): MissionDefinitionType!

  # @Private Add an existing mission task definition to an existing mission definition.
  addTaskToMissionDefinition(
    # Specify the position where the task should be added, by default it will be on the end
    index: Float

    # The id of the mission task definition which should be added.
    missionTaskDefinitionId: String!

    # The mission definition id which should be modified.
    missionDefinitionId: String!
  ): MissionDefinitionType!

  # @Private Remove a task from an existing mission definition.
  removeTaskFromMissionDefinition(
    # The id of the mission task definition which should be removed.
    missionTaskDefinitionId: String!

    # The mission definition id which should be modified.
    missionDefinitionId: String!
  ): MissionDefinitionType!

  # @Private Change the index of an existing task in a mission definition.
  reorderTaskInMissionDefinition(
    # The new index of the mission task definition.
    index: Float!

    # The id of the mission task definition which should be reordered.
    missionTaskDefinitionId: String!

    # The mission definition id which should be modified.
    missionDefinitionId: String!
  ): MissionDefinitionType!

  # @Internal Remove a specific mission definition. It is not possible to restore it!
  deleteMissionDefinition(
    # The id of the mission definition which should be deleted.
    id: String!
  ): MissionDefinitionType!

  # @Private Create a new dock robot task definition.
  createDockRobotTaskDefinition(
    # The parameters to create the task definition.
    input: CreateDockRobotTaskDefinitionInput!
  ): DockRobotTaskDefinitionType!

  # @Private Create a new point of interest inspection task definition.
  createPoiInspectionTaskDefinition(
    # The parameters to create the task definition.
    input: CreatePoiInspectionTaskDefinitionInput!
  ): PoiInspectionTaskDefinitionType!

  # @Private Create a new waypoint task definition.
  createWaypointTaskDefinition(
    # The parameters to create the task definition.
    input: CreateWaypointTaskDefinitionInput!
  ): WaypointTaskDefinitionType!

  # @Private Open a new chat on a robot. This endpoint ensures that the involved chat room is available and the user is member of it
  openRobotChat(
    # The id of the robot
    robotId: String!
  ): Boolean!

  # @Private Send a new message into a robot chat
  sendRobotMessage(
    # The payloads to send the message
    input: SendMessageInput!

    # The id of the robot
    robotId: String!
  ): ChatMessageType!

  # @Internal Allow a human robot supervisor to create a new session.
  openHumanRobotSupervisorSession(
    # The id of the robot.
    robotId: String!
  ): HumanRobotSupervisorSessionType!

  # @Internal Allow a human robot supervisor to create an existing session.
  closeHumanRobotSupervisorSession(
    # The id of the robot.
    robotId: String!
  ): HumanRobotSupervisorSessionType!

  # @Private Accept the human robot supervisor session. The human robot supervisor will take over the principal driver role.
  acceptHumanRobotSupervisorSession(
    # The id of the robot.
    robotId: String!
  ): HumanRobotSupervisorSessionType!

  # @Private Decline the human robot supervisor session.
  declineHumanRobotSupervisorSession(
    # The id of the robot.
    robotId: String!
  ): HumanRobotSupervisorSessionType!

  # @Internal Become the new principal driver for the provided robot. This is a legacy function to allow er_web_api to update the principal driver. In all new systems please use 'becomePrincipal' mutation.
  becomePrincipalDriverLegacy(
    # The parameters to create a new principal driver.
    input: CreatePrincipalDriverInput!

    # The id of the robot the principal driver should be requested from.
    robotId: String!
  ): PrincipalDriverType!

  # @Private Become the new principal driver for the provided robot.
  becomePrincipalDriver(
    # The id of the robot the principal driver should be requested from.
    robotId: String!
  ): PrincipalDriverType!

  # @Private Provide an SDP offer to the WebRTC service. If successful it will return the SDP response.
  connectWebRtc(
    # The sdp offer.
    sdpOffer: Sdp!

    # The id of the robot the WebRTC connection is requested for.
    robotId: String!

    # The type of the web rtc connection.
    connectionType: WebRtcConnectionTypeEnum!
  ): WebRtcHandshakeResponseType!

  # @Private Provides the local generated ICECandidates to the WebRTC service.
  addIceCandidate(
    # The new  ICECandidate.
    input: CreateIceCandidateInput!

    # The id of the connection related robot.
    robotId: String!

    # The type of the web rtc connection.
    connectionType: WebRtcConnectionTypeEnum!

    # The id of the webrtc connection
    id: String!
  ): Boolean!

  # @Private Request the WebRTC backchannel for a provided robot
  requestWebRtcBackchannel(
    # The id of the robot the WebRTC backchannel is requested for.
    robotId: String!

    # The id of the webrtc connection
    id: String!
  ): Boolean!

  # @Internal Allows a robot to provide status updates to the cloud core api. These updates are pushed to all available subscriptions
  updateRobotState(
    input: UpdateRobotStateInput
    robotID: String!
  ): RobotStatusType!

  # Enables to wake up a robot or sending it to sleep. Please note that depending on the robot type this might take several minutes.
  executeAwakeCommand(
    # The new state the robot should be in.
    targetState: AwakeStateEnum!

    # The id of the robot.
    robotID: String!
  ): RobotCommandExecutionType!

  # Enables to toggle the robots motors. Please note that depending on the robot type this might take some time.
  executeMotorEnabledCommand(
    # The new state the robot should be in.
    targetState: Boolean!

    # The id of the robot.
    robotID: String!
  ): RobotCommandExecutionType!

  # Send a initial pose guess to the robot for the localization
  executeSetInitialRobotPoseCommand(
    # The new pose
    pose: Pose3DStampedInput!

    # The id of the robot.
    robotId: String!
  ): RobotCommandExecutionType!

  # Take a photo with a specific camera on the robot
  executeTakePhotoCommand(
    # Optional options for the photo command.
    input: TakePhotoCommandOptionsInput = {}

    # The id of the robot.
    cameraId: String!

    # The id of the robot.
    robotId: String!
  ): RobotCommandExecutionType!

  # @Internal Allows the robot to accept a request.
  robotCommandResponse(
    # The id of the command execution
    robotCommandExecutionID: String!
  ): RobotCommandExecutionType!

  # @Internal Allows the robot to send a result for an existing command execution. This terminates the command.
  robotCommandResult(
    # The id command execution
    result: RobotCommandExecutionResultEnum!

    # The id of the command execution.
    robotCommandExecutionID: String!
  ): RobotCommandExecutionType!

  # Start or resume an autonomous mission with a specific robot.
  startMissionExecution(
    # The parameters to configure the autonomous mission execution.
    input: StartMissionExecutionInput!
  ): MissionExecutionType!

  # Pause a running mission execution, this also stops the robot. Please do not use this mutation to implement an emergency stop!
  pauseMissionExecution(
    # The id of the robot.
    robotID: String!
  ): MissionExecutionType!

  # @Private Update the current mission task to the provided one. The task between the current task and the new selected task are skipped.
  continueMissionExecutionWithTask(
    # The id of the task that should be the next executed task.
    missionTaskDefinitionId: String!

    # The id of the robot.
    robotId: String!
  ): MissionExecutionType!

  # @Internal This mutation is used by a robot to accept or reject mission execution requests. It also may be used to trigger a teleoperated mission by the robot.
  startMissionExecutionFromRobot(
    # The parameters to configure the mission execution.
    input: StartMissionExecutionFromRobotInput!
  ): MissionExecutionType!

  # @Internal Allows the robot to update current mission execution. The updates are published to all connected clients.
  updateMissionExecutionFeedbackFromRobot(
    # The parameter for the mission execution update.
    input: MissionExecutionFeedbackFromRobotInput!

    # The id of the robot that sent the mission execution feedback.
    robotId: String!
  ): MissionExecutionStatusType!

  # @Internal Allows the robot to update the current path. The updates are published to all connected clients.
  updateCurrentPathToDrive(
    # The trajectory
    input: [Pose3DStampedInput!]!

    # The id of the robot.
    robotId: String!
  ): [Pose3DStampedType!]!

  # @Internal Send a robot event and notify event subscribers.
  sendRobotEvent(
    # The diagnostics of the event
    input: [CreateDiagnosticsInput!]!

    # The id of the robot the event is originated from.
    robotId: String!
  ): EventType!

  # @Private Create a customer event without notifying event subscribers.
  createCustomerEvent(
    # The data required to create a customer event
    input: CreateCustomerDiagnosticsInput!

    # The id of the robot connected with the event.
    robotId: String!
  ): EventType!

  # @Private Mark an existing event with a customer flag.
  markEventWithCustomerFlag(
    # The data required to create a customer flag.
    input: CreateCustomerFlagInput!

    # The id of the event.
    eventId: String!
  ): EventType!

  # @Private Execute the undocking command on a robot. The robot needs to be on the docking station for that action.
  executeUndockRobot(
    # The id of the robot.
    robotId: String!
  ): MissionExecutionType!

  # @Private Execute the docking command on a robot. Currently the robot needs to be in front of the docking station (The visual tag needs to be visible in the front camera).
  executeDockRobot(
    # The docking station the robot should dock in.
    dockingStationId: String!

    # The id of the robot.
    robotId: String!
  ): MissionExecutionType!

  # @Internal Create a new mission report with the provided external key. If a mission report with that key is already available than the existing report is updated.
  upsertMissionReport(
    # The parameters to create a new mission report.
    input: CreateMissionReportInput!
  ): MissionReportType!

  # @Internal Set the diagnostics of a mission report by key.
  setMissionReportDiagnosticsByKey(
    # The diagnostics messages accorded during the mission
    diagnostics: [CreateDiagnosticsInput!]!

    # The key of the desired mission report.
    key: String!
  ): MissionReportType!

  # @Internal Set the mission definitions of a mission report by key.
  setMissionReportMissionDefinitionsByKey(
    # The mission definition ids. The report stores the current snapshot of the mission definitions.
    missionDefinitionIds: [String!]!

    # The key of the desired mission report.
    key: String!
  ): MissionReportType!

  # @Internal Set the trajectory of the robot during this mission.
  setMissionReportTrajectoryByKey(
    # The URI to the trajectory file. Currently it's just the filename
    trajectoryUri: String!

    # The key of the desired mission report.
    key: String!
  ): MissionReportType!

  # @Internal Set the time range of the mission this mission report represents.
  setMissionReportTimeRangeByKey(
    # The end timestamp of the mission.
    endTimestamp: Timestamp!

    # The start timestamp of the mission.
    startTimestamp: Timestamp!

    # The key of the desired mission report.
    key: String!
  ): MissionReportType!

  # @Internal Create new photo data payload.
  upsertPhotoDataPayload(
    input: CreatePhotoDataPayloadInput!
  ): PhotoDataPayloadType!

  # @Internal Create new audio data payload.
  upsertAudioDataPayload(
    input: CreateAudioDataPayloadInput!
  ): AudioDataPayloadType!

  # @Internal Create new video data payload.
  upsertVideoDataPayload(
    input: CreateVideoDataPayloadInput!
  ): VideoDataPayloadType!

  # @Internal Create new time series 1D data payload.
  upsertTimeSeries1DDataPayload(
    input: CreateTimeSeries1dDataPayloadInput!
  ): TimeSeries1DDataPayloadType!

  # @Internal Create new photo overlay data payload.
  upsertPhotoOverlayDataPayload(
    input: CreatePhotoOverlayDataPayloadInput!
  ): PhotoOverlayDataPayloadType!

  # @Internal Create new JSON data payload.
  upsertJSONDataPayload(
    input: CreateJSONDataPayloadInput!
  ): JSONDataPayloadType!

  # @Internal Create a new group data payload.
  upsertGroupDataPayload(
    input: CreateGroupDataPayloadInput!
  ): GroupDataPayloadType!
}

# The payload necessary to update an existing site.
input UpdateSiteInput {
  # The human-readable name of the site.
  name: String

  # A location description of the site.
  location: String
}

input SiteSensorConfigLimitInput {
  # The lower limit of the sensor.
  lower: Float

  # The upper limit of the sensor.
  upper: Float

  # The tag associated with these limits.
  tag: String!
}

input UpdateSitePointCloudConfigInput {
  # The color of the point cloud.
  color: UpdateSitePointCloudColorConfigInput

  # The size of the points.
  size: Float
}

input UpdateSitePointCloudColorConfigInput {
  # The type of the point cloud.
  type: PointCloudShadingTypeEnum

  # The color of the point cloud.
  value: Color

  # The opacity of the color.
  opacity: Float
}

input CreateSiteInput {
  number: Int!
  name: String!
  location: String
}

input AddSitePointCloudConfigInput {
  # An uri to the point cloud resource (either the file or the data stream).
  uri: Uri!

  # The type of the point cloud.
  type: PointCloudTypeEnum!

  # The color of the point cloud.
  color: AddSitePointCloudColorConfigInput!

  # The size of the points.
  size: Float!
}

input AddSitePointCloudColorConfigInput {
  # The type of the point cloud.
  type: PointCloudShadingTypeEnum!

  # The color of the point cloud.
  value: Color

  # The opacity of the color.
  opacity: Float!
}

# Payload to create a new robot
input CreateRobotInput {
  # The human-readable name of the robot
  name: String!

  # The robot number is unique number for each robot
  number: Float!

  # The type of the robot
  type: RobotTypeEnum!
}

# The payload necessary to add a new point of interest.
input AddPointOfInterestInput {
  # The name of the poi
  name: String!

  # The name of the poi
  site: String!

  # The reference frame used by this POI (map, world, ...)
  frame: String!

  # The type of the poi.
  type: PointOfInterestTypeEnum!

  # The pose of the poi.
  pose: Pose3DInput!

  # The photo action associated with the point of interest.
  photoAction: PointOfInterestActionPhotoInput

  # The video action associated with the point of interest.
  videoAction: PointOfInterestActionVideoInput
}

# The parameters necessary to create a new 3D pose.
input Pose3DInput {
  # The position of the pose.
  position: Point3DInput!

  # The orientation of the pose.
  orientation: QuaternionInput!
}

# Parameters to create a new 3D point.
input Point3DInput {
  x: Float!
  y: Float!
  z: Float!
}

# Parameters to create a new 3D orientation represented as a unit quaternion. Note that the quaternion needs to be normalized!
input QuaternionInput {
  w: Float!
  x: Float!
  y: Float!
  z: Float!
}

# The photo action when adding a POI
input PointOfInterestActionPhotoInput {
  # The pose of the robot.
  robotPose: Pose3DInput!

  # The sensor name used to take a photo with. (front_cam_link, inspection_cam_link, ...)
  sensor: String!
}

# The video action when adding a POI
input PointOfInterestActionVideoInput {
  # The pose of the robot.
  robotPose: Pose3DInput!

  # The sensor name used to take a video with. (front_cam_link, inspection_cam_link, ...)
  sensor: String!

  # The action type
  duration: Float!
}

# The payload necessary to create or update a point of interest.
input UpsertPointOfInterestInput {
  # The external generated uuid of the poi. If the key is already available, the existing payload is updated.
  key: String!

  # The name of the poi
  name: String!

  # The type the new poi.
  type: PointOfInterestTypeEnum!

  # The site, this poi should be added to.
  siteId: String!

  # The pose of the poi.
  pose: Pose3DStampedInput!

  # The producer of the point of interest.
  producer: PointOfInterestProducerInput!

  # The inspection parameters of this poi.
  inspectionParameters: Json!
}

# Parameters to create a new 3D pose at a given timestamp in an optional coordinate frame.
input Pose3DStampedInput {
  # The timestamp the data is generated.
  timestamp: Timestamp!

  # The reference coordinate frame, the data is associated with
  frameID: String

  # Represents the position of the pose.
  position: Point3DInput!

  # Represents the orientation of the pose.
  orientation: QuaternionInput!
}

# The payload necessary to create a point of interest producer.
input PointOfInterestProducerInput {
  # The robot number.
  type: PointOfInterestProducerTypeEnum!

  # The robot number.
  robotNumber: Int

  # The robot type.
  robotType: RobotTypeEnum
}

# Describes the different ways a point of interest has been produced.
enum PointOfInterestProducerTypeEnum {
  # The point of interest is the result of teaching process with the robot.
  ROBOT_TEACHING

  # The point of interest is defined by a visual marker.
  VISUAL_MARKER

  # The point of interest is the result of a manual import of the user.
  MANUAL_IMPORT
}

# The payload necessary to update an existing point of interest.
input UpdatePointOfInterestInput {
  # The name of the poi
  name: String

  # The type of the poi.
  type: PointOfInterestTypeEnum

  # The pose of the poi.
  pose: UpdatePose3DStampedInput
}

# The parameters necessary to update an existing stamped 3D pose.
input UpdatePose3DStampedInput {
  # The timestamp the data is generated.
  timestamp: Timestamp

  # The reference coordinate frame, the data is associated with
  frameID: String

  # Represents the position of the pose.
  position: Point3DInput

  # Represents the orientation of the pose.
  orientation: QuaternionInput
}

input CreateAreaOfInterestInput {
  name: String!
  siteID: String!
}

# Parameters to create a new docking station site object.
input CreateDockingStationSiteObjectInput {
  # An external provided uuid to re-identify the site object.
  key: String!

  # The name of the site object.
  name: String!

  # The pose of the object in the world.
  pose: Pose3DStampedInput!

  # The waypoint in front of the docking station that allows it to perform the docking behavior.
  waypoint: Pose3DStampedInput!

  # The robot type that is compatible with this docking station.
  compatibleRobotType: RobotTypeEnum!
}

# Payloads to create the description of a single camera
input AddCameraDescriptionInput {
  # The human readable name of the camera
  name: String!

  # The topic name of the camera used by the signaling server
  webRtcTopic: String!
}

# Payloads to add a new sensor description
input AddSensorDescriptionInput {
  # The pysical data port on the robot
  dataPort: Int!

  # The pysical power port on the robot
  powerPort: Int!

  # An offset of the analog signal. It is assumed to be zero if not set.
  analogInZeroOffset: Float

  # The description of the sensor data
  dataDescription: AddSensorDataDescriptionInput!
}

# Payload to add sensor data description
input AddSensorDataDescriptionInput {
  # The human readable name of the data measured by the sensor.
  name: String!

  # An abbreviation of the name
  abbreviation: String!

  # The physical unit of the measurements
  unit: String!

  # The unit range of sensor data. We assume the lower bound to be 0 (e.g. resulting unit range is [0, unitRange])
  unitRange: Float!

  # An optional discretization of the sensor data
  discretization: [AddSensorDataDiscretizationInput!]
}

# Payload to create a bin for a sensor data discretization
input AddSensorDataDiscretizationInput {
  # The name of the bin
  name: String!

  # The minimum value
  minValue: Float!

  # The maximum value
  maxValue: Float!
}

# Payload to update a sensor description
input UpdateSensorDescriptionInput {
  # The physical data port on the robot
  dataPort: Int!

  # The physical power port on the robot
  powerPort: Int!

  # The description of the sensor data
  dataDescription: UpdateSensorDataDescriptionInput!
}

# Payload to add sensor data description
input UpdateSensorDataDescriptionInput {
  # The human readable name of the data measured by the sensor.
  name: String!

  # An abbreviation of the name
  abbreviation: String!

  # The physical unit of the measurements
  unit: String!

  # The unit range of sensor data. We assume the lower bound to be 0 (e.g. resulting unit range is [0, unitRange])
  unitRange: Float!

  # An optional discretization of the sensor data
  discretization: [UpdateSensorDataDiscretizationInput!]
}

# Payload to create a bin for a sensor data discretization
input UpdateSensorDataDiscretizationInput {
  # The name of the bin
  name: String!

  # The minimum value
  minValue: Float!

  # The maximum value
  maxValue: Float!
}

# Parameters to create a new mission definition.
input CreateMissionDefinitionInput {
  # The site the new mission belongs to
  siteId: String!

  # The legacy mission definition id from the er_web_api.
  legacyMissionDefinitionId: String

  # The name of the mission.
  name: String!

  # Specify the requirements of the robot which should be able to execute this mission definition.
  requiredRobotConfig: CreateRequiredRobotConfigInput
}

# Parameters to create a new required robot config.
input CreateRequiredRobotConfigInput {
  # Force this mission to be only available for a specific robot.
  robotId: String
}

# Parameters to create a new dock robot task definition.
input CreateDockRobotTaskDefinitionInput {
  # The id of the site this task should associated with.
  siteId: String!

  # A human readable name of the task.
  name: String!

  # The id of the docking that should be used in the task.
  dockingStationId: String!
}

# Parameters to create a new point of interest inspection task definition.
input CreatePoiInspectionTaskDefinitionInput {
  # The id of the site this task should associated with.
  siteId: String!

  # A human readable name of the task.
  name: String!

  # The id of the poi which should be inspected.
  poiId: String!
}

# Parameters to create a new waypoint task definition.
input CreateWaypointTaskDefinitionInput {
  # The id of the site this task should associated with.
  siteId: String!

  # A human readable name of the task.
  name: String!

  # The pose of the waypoint
  waypoint: Pose3DStampedInput!
}

# Data payload to generate a new chat message.
input SendMessageInput {
  # The text message
  message: String!
}

input CreatePrincipalDriverInput {
  userId: Float!
  name: String!
  email: String!
}

# Represents the different types of WebRTC connections.
enum WebRtcConnectionTypeEnum {
  # The (bidirectional) data channel connection to the robot.
  ROBOT_DATA_CHANNEL
}

# Create a ICE (Interactive Connectivity Establishment) configuration which is used to establish a WebRTC connection.
input CreateIceCandidateInput {
  # A DOMString describing the properties of the candidate.
  candidate: IceCandidate!

  # A DOMString which uniquely identifies the source media component from which the candidate draws data, or null if no such association exists for the candidate.
  sdpMid: String!

  # A number containing a 0-based index into the set of m-lines providing media descriptions, indicating which media source is associated with the candidate, or null if no such association is available.
  sdpMLineIndex: Int!
}

input UpdateRobotStateInput {
  isConnected: Boolean
  awakeState: AwakeStateEnum
  batteryStatus: BatteryStatusInput
  connectionStatus: ConnectionStatusInput
  isEmergencySwitchPressed: Boolean
  isMotorsEnabled: Boolean
  isDocking: Boolean
}

# Represents the internal awake state of the robot. Not to confused with the 'AwakeStatusEnum' which also provides details about the transition states.
enum AwakeStateEnum {
  # The robot is fully available. This state is mandatory to perform actions on the robot or get access to sensor data (e.g. camera images). In this state, the robot has larger battery consumption even if the robot does not executes any tasks.
  AWAKE

  # In this state, the robot is in a low-power mode. It is still connected to the cloud and publishes its status but at a significantly lower frequency. It is also possible to wake the robot up remotely. All other consumers are shut down.
  ASLEEP
}

input BatteryStatusInput {
  percentage: Float!
  chargingState: ChargingStateEnum!
  chargerType: ChargerTypeEnum!
  chargingCurrent: ElectricCurrent!
}

input ConnectionStatusInput {
  type: ConnectionTypeEnum!
  networkName: String!
  signalStrength: Float!
}

input TakePhotoCommandOptionsInput {
  # The region of interest the photo should be taken. All coordinates have to be provided as percentage values relative to the full image dimensions.
  regionOfInterest: RegionOfInterestInput
}

input RegionOfInterestInput {
  x: Float!
  y: Float!
  width: Float!
  height: Float!
}

# The parameters to start an autonomous mission
input StartMissionExecutionInput {
  # The mission definition which should be executed autonomously.
  missionDefinitionID: String!

  # The id of the robot, which should execute the mission.
  robotID: ID!
}

# Only for internal use. The parameters to start a mission from the robot.
input StartMissionExecutionFromRobotInput {
  # The id of the robot, which should execute the mission.
  robotID: ID!

  # The initial mission execution status.
  status: MissionExecutionStatusEnum!

  # The control mode the new mission has been started.
  controlMode: ControlModeEnum!

  # The current principal driver who started the mission.
  principal: PrincipalDriverInput!
}

input PrincipalDriverInput {
  userId: Float!
  name: String!
  email: String!
}

# Only for internal use. Parameters for the robot to updated a mission execution.
input MissionExecutionFeedbackFromRobotInput {
  # The new mission execution status. Note: COMPLETED will close the mission execution.
  status: MissionExecutionStatusEnum!

  # The mission definition executed autonomously.
  missionDefinitionId: String!

  # The currently executed task id.
  currentExecutedTaskId: String!
}

# Represents all data to generate a new diagnostic message.
input CreateDiagnosticsInput {
  # The timestamp the event happens.
  timestamp: Timestamp!

  # The type/level of this message. This might be an hint how critical the message is.
  type: DiagnosticsTypeEnum!

  # The component which has generated the diagnostic message.
  component: String

  # The diagnostic value.
  value: DiagnosticsValueEnum!

  # The diagnostic message.
  key: String = null
}

# Represents the set of all possible diagnostic values. It is a union of different types. Currently it consists of: MissionExecutionFailureEnum
enum DiagnosticsValueEnum {
  # A stop tag has been detected.
  MISSION_FAILURE_STOP_TAG

  # The robot has lost the line.
  MISSION_FAILURE_LINE_LOST

  # The wired quick charger is still connected.
  MISSION_FAILURE_QUICK_CHARGER_CONNECTED

  # The emergency stop is still pressed.
  MISSION_FAILURE_ESTOP_PRESSED

  # Nobody is supervising the robot.
  MISSION_FAILURE_WATCHDOG_LOST

  # A sensor value is above the maximum threshold.
  MISSION_FAILURE_SENSOR_LEVEL_ABOVE_THRESHOLD

  # A sensor value is below the minimum threshold.
  MISSION_FAILURE_SENSOR_LEVEL_BELOW_THRESHOLD

  # The battery level is to low to continue the mission.
  MISSION_FAILURE_LOW_BATTERY

  # The robot detected a potential collision with an obstacle.
  MISSION_FAILURE_COLLISION_DETECTED

  # An failure which cannot identified has been accrued during the mission execution.
  MISSION_FAILURE_UNKNOWN

  # An failure which cannot identified has been accrued
  UNKNOWN
    @deprecated(
      reason: "Changed convention, use 'MISSION_FAILURE_UNKNOWN' instead."
    )
}

# Represents all data to generate a diagnostic message issued by the customer.
input CreateCustomerDiagnosticsInput {
  # The type/level of this message. This might be an hint how critical the message is.
  type: DiagnosticsTypeEnum!

  # The diagnostic message key.
  value: String!

  # The reason to flag
  reason: String!
}

# Represents the data to generate customer flag.
input CreateCustomerFlagInput {
  # The reason to flag
  reason: String!
}

# Only for internal use. Parameters to create a new mission report.
input CreateMissionReportInput {
  # An external provided uuid to re-identify the mission report (e.g. to prevent duplicates).
  key: String!

  # The start timestamp of the mission execution.
  startTimestamp: Timestamp!

  # The end timestamp of the mission execution.
  endTimestamp: Timestamp

  # The specific robot snapshot, which has executed the mission. The exact configuration of the robot during the mission is preserved even if the robot configuration changes in the future or removed from the site.
  robotNumber: Float!

  # The filename of the file which contains the trajectory driven by the robot during this mission.
  trajectoryUri: String

  # The ids of the mission definition (if available) which has been executed during the period of this mission report.
  missionDefinitionIds: [ID!] = []
}

# Parameters to create a new photo data payload.
input CreatePhotoDataPayloadInput {
  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The producer of this payload. Can be null for payloads which has been generated directly from the robot (e.g. images, videos, audios).
  producer: CreateDataPayloadProducerInput

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # The id of the robot snapshot which has generated the payload.
  robotNumber: Float!

  # The timestamp the original payload has been recorded. This timestamp is propagated to child payloads and is used to assign the payload to mission reports. If a parentPayloadKey is provided, this field is ignored.
  acquisitionTimestamp: Timestamp

  # The point of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  pointOfInterestId: String

  # The area of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  areaOfInterestId: String

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean

  # Metadata associated with this data payload.
  jsonMetaData: Json

  # The timestamp the data has been generated.
  timestamp: Timestamp!

  # The uri to access the photo. (Currently only the filename is provided.)
  uri: String!
}

# Parameters to create a payload producer.
input CreateDataPayloadProducerInput {
  # An dot seperated identifier that groups skills of the same provider. E.g.: com.energy-robotics
  group: String!

  # A human readable name of the skill that produced the payload.
  name: String!
}

# Parameters to create a new audio data payload.
input CreateAudioDataPayloadInput {
  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The producer of this payload. Can be null for payloads which has been generated directly from the robot (e.g. images, videos, audios).
  producer: CreateDataPayloadProducerInput

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # The id of the robot snapshot which has generated the payload.
  robotNumber: Float!

  # The timestamp the original payload has been recorded. This timestamp is propagated to child payloads and is used to assign the payload to mission reports. If a parentPayloadKey is provided, this field is ignored.
  acquisitionTimestamp: Timestamp

  # The point of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  pointOfInterestId: String

  # The area of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  areaOfInterestId: String

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean

  # Metadata associated with this data payload.
  jsonMetaData: Json

  # The start timestamp of the audio file.
  fromTimestamp: Timestamp!

  # The end timestamp of the audio file.
  toTimestamp: Timestamp!

  # The uri to access the audio file. (Currently only the filename is provided.)
  uri: String!
}

# Parameters to create a new video data payload.
input CreateVideoDataPayloadInput {
  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The producer of this payload. Can be null for payloads which has been generated directly from the robot (e.g. images, videos, audios).
  producer: CreateDataPayloadProducerInput

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # The id of the robot snapshot which has generated the payload.
  robotNumber: Float!

  # The timestamp the original payload has been recorded. This timestamp is propagated to child payloads and is used to assign the payload to mission reports. If a parentPayloadKey is provided, this field is ignored.
  acquisitionTimestamp: Timestamp

  # The point of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  pointOfInterestId: String

  # The area of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  areaOfInterestId: String

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean

  # Metadata associated with this data payload.
  jsonMetaData: Json

  # The start timestamp of the video.
  fromTimestamp: Timestamp!

  # The end timestamp of the video.
  toTimestamp: Timestamp!

  # The uri to access the video. (Currently only the filename is provided.)
  uri: String!
}

# Parameters to create a new time series 1d data payload.
input CreateTimeSeries1dDataPayloadInput {
  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The producer of this payload. Can be null for payloads which has been generated directly from the robot (e.g. images, videos, audios).
  producer: CreateDataPayloadProducerInput

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # The id of the robot snapshot which has generated the payload.
  robotNumber: Float!

  # The timestamp the original payload has been recorded. This timestamp is propagated to child payloads and is used to assign the payload to mission reports. If a parentPayloadKey is provided, this field is ignored.
  acquisitionTimestamp: Timestamp

  # The point of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  pointOfInterestId: String

  # The area of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  areaOfInterestId: String

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean

  # Metadata associated with this data payload.
  jsonMetaData: Json

  # The uri to access the json file containing the time series
  uri: String!
}

# Parameters to create a new photo  overlay data payload.
input CreatePhotoOverlayDataPayloadInput {
  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The producer of this payload. Can be null for payloads which has been generated directly from the robot (e.g. images, videos, audios).
  producer: CreateDataPayloadProducerInput

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # The id of the robot snapshot which has generated the payload.
  robotNumber: Float!

  # The timestamp the original payload has been recorded. This timestamp is propagated to child payloads and is used to assign the payload to mission reports. If a parentPayloadKey is provided, this field is ignored.
  acquisitionTimestamp: Timestamp

  # The point of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  pointOfInterestId: String

  # The area of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  areaOfInterestId: String

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean

  # Metadata associated with this data payload.
  jsonMetaData: Json

  # The timestamp the data has been generated.
  timestamp: Timestamp!

  # The uri to access the photo. (Currently only the filename is provided.)
  uri: String!

  # The uri to access the overlay. (Currently only the filename is provided.)
  overlayUri: String!
}

# Parameters to create a new JSON data payload.
input CreateJSONDataPayloadInput {
  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The producer of this payload. Can be null for payloads which has been generated directly from the robot (e.g. images, videos, audios).
  producer: CreateDataPayloadProducerInput

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # The id of the robot snapshot which has generated the payload.
  robotNumber: Float!

  # The timestamp the original payload has been recorded. This timestamp is propagated to child payloads and is used to assign the payload to mission reports. If a parentPayloadKey is provided, this field is ignored.
  acquisitionTimestamp: Timestamp

  # The point of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  pointOfInterestId: String

  # The area of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  areaOfInterestId: String

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean

  # Metadata associated with this data payload.
  jsonMetaData: Json

  # The JSON data structure.
  jsonData: Json!

  # Data accessors to highlight important fields in the jsonData field.
  dataAccessors: [CreateJSONDataAccessorInput!]
}

# Parameters to create a new JSON data accessor
input CreateJSONDataAccessorInput {
  # A human readable name of the data field.
  name: String!

  # A key accessor in dot notation. (e.g. jsonData.subfield.subsubfield).
  accessor: String!
}

# Parameters to create a new group data payload.
input CreateGroupDataPayloadInput {
  # An external provided uuid to re-identify the payload (e.g. to prevent duplicates).
  key: String!

  # The payload from which this payload has been derived from (e.g. a skill has performed on a payload with the parentPayloadKey to produce this payload.
  parentPayloadKey: String

  # The producer of this payload. Can be null for payloads which has been generated directly from the robot (e.g. images, videos, audios).
  producer: CreateDataPayloadProducerInput

  # A label provided by the skill provider which allows him/her to re-identify his/her payloads
  dataLabel: String

  # The id of the robot snapshot which has generated the payload.
  robotNumber: Float!

  # The timestamp the original payload has been recorded. This timestamp is propagated to child payloads and is used to assign the payload to mission reports. If a parentPayloadKey is provided, this field is ignored.
  acquisitionTimestamp: Timestamp

  # The point of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  pointOfInterestId: String

  # The area of interest id, the data is recorded at. Please note that only a POI or an AOI can be provided at the same time.
  areaOfInterestId: String

  # Represents the POI name specified in the mission editor.
  poiName: String

  # Whether or not the data is synced from the robot to the cloud.
  isSynced: Boolean

  # Metadata associated with this data payload.
  jsonMetaData: Json

  # The is of the payloads which should be grouped together.
  group: [String!]!
}

type Subscription {
  # @Private Subscribe to site config updates.
  onSiteConfigUpdate(
    # The id of the site the config should requested from.
    siteId: String!
  ): SiteConfigType!
    @deprecated(reason: "[19.01.2023] redundant, please use onSite instead")

  # @Private Subscribe to site updates.
  onSite(
    # The id of the site.
    siteId: String!
  ): SiteSubscriptionType!

  # @Private Subscribe to robot config updates
  onRobotConfigUpdate(
    # The id of the robot
    robotId: String!
  ): RobotSubscriptionType!

  # @Private Subscribe to stage changes changes
  onSiteStage(
    # The id of the affected site stage
    siteStageId: String!
  ): SiteStageStatusType!

  # @Private Subscribe to updates of points of interest of a site.
  onPointOfInterest(
    # The id of the site the points of interest should requested from.
    siteId: String!
  ): PointOfInterestSubscriptionType!

  # @Private Get updates for the site recordings for a robot.
  onSiteRecordingStatus(
    # The id of the robot.
    robotId: String!
  ): SiteRecordingStatusType!

  # @Internal Internal subscription to receive site recording requests
  onSiteRecordingControlRequest(
    # The id of the robot.
    robotId: String!
  ): SiteRecordingControlRequestType!

  # @Private Subscribe to updates of mission definitions for a provided site.
  onMissionDefinition(
    # The id of the site the mission definition should requested from.
    siteId: String!
  ): MissionDefinitionSubscriptionType!

  # @Private Subscribe to the chat messages of a robot
  onRobotMessage(
    # The id of the robot
    robotId: String!
  ): ChatMessageType!

  # @Private Subscribe to the human robot supervisor session of a robot.
  onHumanRobotSupervisorSession(
    # The id of the robot
    robotId: String!
  ): HumanRobotSupervisorSessionStatusType!

  # Subscribe to the current principal driver for a given robot.
  onPrincipalDriverStatus(
    # The id of the robot the principal driver should requested from.
    robotId: String!
  ): PrincipalDriverStatusType!

  # @Private Subscribe to the remote generated ICECandidates.
  onIceCandidatesStatus(
    # The id of the connection related robot.
    robotId: String!

    # The type of the web rtc connection.
    connectionType: WebRtcConnectionTypeEnum!

    # The id of the webrtc connection
    id: String!
  ): IceCandidatesStatusType!

  # Subscribe to the latest robot status of a given robot. After the subscription, the latest status is returned, even if the robot is not available.
  onRobotStatus(
    # The id of the robot the status should requested from.
    robotID: String!
  ): RobotStatusType!

  # Subscribe to the latest robot statuses for a selection of robots
  onRobotStatuses(
    # The ids of the robots the status should requested from.
    robotIDs: [String!]!
  ): [StatusPerRobotType!]!

  # Subscribe to the latest robot statuses for the selected site ID.
  onRobotStatusesPerSite(
    # The id of the site the robot status should be subscribed from.
    siteID: String!
  ): [StatusPerRobotType!]!

  # Allows a client to receive details of running robot command execution. Note this subscriber provides data for all commands of a robot. A particular execution may be filtered using the robot command execution id.
  onRobotCommandExecutionStatus(
    # The id of the robot.
    robotID: String!
  ): RobotCommandExecutionStatusType!

  # @Internal Allows a robot to receive new command execution requests.
  onRobotCommandExecutionRequest(
    # The id of the robot.
    robotID: String!
  ): RobotCommandExecutionRequestType!

  # Subscribe to the current mission execution for a given robot.
  onMissionExecutionStatus(
    # The id of the robot the mission execution should requested from.
    robotID: String!
  ): MissionExecutionStatusType!

  # @Internal Subscribe to new mission requests by the Cloud Core API. This subscription is used by robots to be informed about new requests
  onMissionExecutionControlRequest(
    # The id of the robot.
    robotID: String!
  ): MissionExecutionControlRequestType!

  # @Private Subscribe to the current path which is driven by the robot.
  onCurrentPathToDrive(
    # The id of the robot the path should be subscribed from.
    robotId: String!
  ): TrajectorySubscriptionType!

  # @Private Subscribe to the events of a robot.
  onRobotEvents(
    # The id of the robot the events should requested from.
    robotId: String!
  ): EventType!

  # Subscribe to new or updated mission reports of a site.
  onMissionReportBySite(
    # The id of the site the mission reports should requested from.
    siteId: String!
  ): MissionReportSubscriptionType!

  # Subscribe to new or updated mission reports of a robot.
  onMissionReportByRobot(
    # The id of the robot the mission reports should requested from.
    robotId: String!
  ): MissionReportSubscriptionType!

  # Subscribe to new recorded or updated data payloads of a robot.
  onDataPayloadByRobot(
    # Specify the payload types which should be considered. If this parameter is not set all types are considered.
    types: [DataPayloadTypeEnum!]

    # The id of the robot the data payload should requested from.
    robotId: String!
  ): DataPayloadSubscriptionType!
}
